<!DOCTYPE html>
<html lang="en">
<head>
   <!-- Removed redundant script.js include as code is inline -->

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AB Wallet</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
    <!-- Optional: Include tinycolor library for advanced color manipulation -->
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.6.0/tinycolor.min.js"></script> -->

    <style>
        :root {
            --bg-color: #121212;
            --primary-text: #ffffff;
            --secondary-text: #b3b3b3;
            --card-bg: #1e1e1e;
            --accent-color: #1DB954;
            --button-bg: #1DB954;
            --button-text: #ffffff;
            --input-bg: #282828;
            --border-color: #333333;
            --error-color: #f44336;
            --success-color: #4caf50;
            --warning-color: #ffa726;
            --link-color: #8774e1;
            --receive-color: var(--success-color);
            --send-color: var(--error-color);
            --swap-color: #ff9800;
            --hover-bg: rgba(255, 255, 255, 0.05);
            --modal-bg: #2a2a2a; /* Darker modal background */
            --modal-overlay-bg: rgba(0, 0, 0, 0.7);
        }

        /* --- Base Styles --- */
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif; }
        html, body { height: 100%; }
        body { background-color: var(--bg-color); color: var(--primary-text); overscroll-behavior: none; display: flex; flex-direction: column; transition: background-color 0.3s, color 0.3s; }
        .app-container { flex-grow: 1; padding: 20px 15px 75px 15px; overflow-y: auto; -webkit-overflow-scrolling: touch; }

        /* --- Page Sections --- */
        .page { display: none; animation: fadeIn 0.3s ease-in-out; }
        .page.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Navigation --- */
        .bottom-nav { position: fixed; bottom: 0; left: 0; width: 100%; height: 65px; background-color: var(--card-bg); display: flex; justify-content: space-around; align-items: center; border-top: 1px solid var(--border-color); z-index: 1000; box-shadow: 0 -3px 8px rgba(0,0,0,0.3); }
        .nav-item { background: none; border: none; color: var(--secondary-text); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 11px; padding: 8px 5px; transition: color 0.2s ease, transform 0.1s ease; flex: 1; text-align: center; height: 100%; }
        .nav-item svg { width: 24px; height: 24px; margin-bottom: 4px; fill: currentColor; }
        .nav-item.active { color: var(--accent-color); }
        .nav-item:not(.active):hover { color: var(--primary-text); }
        .nav-item:active { transform: scale(0.95); }

        /* --- Common Elements --- */
        h1, h2, h3 { color: var(--primary-text); margin-bottom: 15px; }
        h1 { font-size: 24px; font-weight: 600; text-align: center; margin-bottom: 25px; }
        h2 { font-size: 18px; font-weight: 600; border-bottom: 1px solid var(--border-color); padding-bottom: 10px; margin-bottom: 20px; }
        h3 { font-size: 16px; color: var(--primary-text); margin-bottom: 12px; font-weight: 500; }
        .card { background-color: var(--card-bg); padding: 20px; border-radius: 12px; margin-bottom: 25px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2); }
        .balance-display { font-size: 36px; font-weight: 700; color: var(--primary-text); text-align: center; margin-bottom: 5px; }
        .balance-display span { font-size: 16px; font-weight: normal; color: var(--secondary-text); margin-left: 8px; }
        .balance-subtitle { text-align: center; color: var(--secondary-text); font-size: 14px; margin-top: 0px; margin-bottom: 25px; }
        .user-info p { margin-bottom: 10px; color: var(--secondary-text); font-size: 14px; display: flex; justify-content: space-between; align-items: center; }
        .user-info strong { color: var(--primary-text); font-weight: 500; margin-right: 10px; }
        .user-info span { text-align: right; word-break: break-all; color: var(--primary-text); }
        label { display: block; margin-bottom: 8px; color: var(--secondary-text); font-size: 14px; font-weight: 500; }
        input[type="text"], input[type="number"], select { /* Select kept for fallback/consistency */ width: 100%; padding: 14px 18px; margin-bottom: 15px; background-color: var(--input-bg); border: 1px solid var(--border-color); border-radius: 8px; color: var(--primary-text); font-size: 16px; appearance: none; -webkit-appearance: none; transition: border-color 0.2s ease, box-shadow 0.2s ease; }
        input:focus, select:focus { outline: none; border-color: var(--accent-color); box-shadow: 0 0 0 3px rgba(29, 185, 84, 0.2); }
        input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type="number"] { -moz-appearance: textfield; }
        .input-helper-text { font-size: 12px; color: var(--secondary-text); margin-top: -10px; margin-bottom: 15px; min-height: 16px; display: block; }
        .input-helper-text.warning { color: var(--warning-color); font-weight: 500; }
        button { background: linear-gradient(to right, var(--accent-color), #19a84c); color: var(--button-text); border: none; padding: 15px 20px; border-radius: 30px; cursor: pointer; font-size: 16px; font-weight: 600; text-align: center; width: 100%; transition: all 0.2s ease; margin-top: 15px; display: flex; align-items: center; justify-content: center; gap: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.2); }
        button:hover { opacity: 0.9; box-shadow: 0 4px 8px rgba(0,0,0,0.25); }
        button:active { transform: scale(0.97); box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        button:disabled { background: #444; color: #888; cursor: not-allowed; opacity: 0.6; box-shadow: none; }
        button svg { width: 20px; height: 20px; fill: currentColor; }
        .message { padding: 15px; margin: 20px 0; border-radius: 8px; text-align: center; font-size: 14px; font-weight: 500; border: 1px solid transparent; }
        .message.error { background-color: rgba(244, 67, 54, 0.15); color: var(--error-color); border-color: rgba(244, 67, 54, 0.4); }
        .message.success { background-color: rgba(76, 175, 80, 0.15); color: var(--success-color); border-color: rgba(76, 175, 80, 0.4); }
        .message.info { background-color: rgba(33, 150, 243, 0.15); color: var(--link-color); border-color: rgba(33, 150, 243, 0.4); }
        .loading-indicator { text-align: center; padding: 40px 20px; color: var(--secondary-text); display: none; font-size: 16px; }
        .loading-indicator.active { display: block; }
        .loading-indicator::before { content: ''; display: inline-block; width: 24px; height: 24px; border: 4px solid rgba(255,255,255,0.2); border-radius: 50%; border-top-color: var(--primary-text); animation: spin 1s ease-in-out infinite; margin-right: 12px; vertical-align: middle; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .chat-id-display { background-color: var(--input-bg); padding: 15px 20px; border-radius: 8px; font-family: 'Courier New', Courier, monospace; word-break: break-all; margin-top: 10px; margin-bottom: 10px; border: 1px dashed var(--border-color); cursor: pointer; text-align: center; color: var(--primary-text); font-size: 16px; transition: background-color 0.2s, border-color 0.2s; }
        .chat-id-display:hover { background-color: var(--hover-bg); border-color: var(--accent-color); }
        .copy-feedback { font-size: 13px; color: var(--success-color); text-align: center; height: 20px; margin-bottom: 15px; opacity: 0; transition: opacity 0.3s ease; font-weight: 500; }
        .copy-feedback.visible { opacity: 1; }
        .transaction-history ul { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; }
        .transaction-history li { background-color: transparent; padding: 15px 5px; margin-bottom: 0px; border-bottom: 1px solid var(--border-color); font-size: 14px; color: var(--secondary-text); display: flex; justify-content: space-between; align-items: flex-start; transition: background-color 0.15s ease; }
        .transaction-history li:hover { background-color: var(--hover-bg); }
        .transaction-history li:last-child { border-bottom: none; }
        .transaction-history li .tx-details { flex-grow: 1; margin-right: 10px; display: flex; align-items: flex-start; }
        .transaction-history li .tx-type-icon { width: 22px; height: 22px; margin-right: 12px; flex-shrink: 0; margin-top: 2px; }
        .transaction-history li .tx-main-info { display: inline-block; vertical-align: top; }
        .transaction-history li span.tx-amount { font-weight: 600; color: var(--primary-text); }
        .transaction-history li span.tx-asset { font-weight: 500; color: var(--primary-text); }
        .transaction-history li span.tx-peer { font-size: 12px; display: block; margin-top: 4px; color: var(--secondary-text); word-break: break-all; }
        .transaction-history li span.tx-peer strong { color: var(--primary-text); font-weight: 500; }
        .transaction-history li span.tx-id { font-size: 11px; display: block; margin-top: 5px; color: var(--secondary-text); font-family: monospace; word-break: break-all; opacity: 0.7; cursor: pointer; transition: opacity 0.2s; }
        .transaction-history li span.tx-id:hover { opacity: 1; }
        .transaction-history li .tx-timestamp { font-size: 12px; color: var(--secondary-text); white-space: nowrap; text-align: right; padding-left: 10px; margin-top: 2px; }
        .transaction-history li.receive .tx-amount { color: var(--receive-color); }
        .transaction-history li.send .tx-amount { color: var(--send-color); }
        .transaction-history li.swap .tx-amount { color: var(--swap-color); }
        .transaction-history li.swap span.tx-amount:nth-child(2) { color: var(--receive-color); }
        #appBlocker { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; z-index: 2000; padding: 20px; color: white; display: none; }
        #appBlocker svg { width: 72px; height: 72px; margin-bottom: 20px; }
        #appBlocker h2 { margin-top: 0; border: none; }
        #appBlocker p { margin-bottom: 20px; font-size: 16px; color: var(--secondary-text); }
        #appBlocker button { width: auto; padding: 12px 25px; }
        .token-list-item { display: flex; align-items: center; justify-content: space-between; padding: 12px 5px; border-bottom: 1px solid var(--border-color); transition: background-color 0.15s ease; }
        .token-list-item:hover { background-color: var(--hover-bg); }
        .token-list-item:last-child { border-bottom: none; }
        .token-list-item .token-info { display: flex; align-items: center; }
        .token-list-item img { width: 36px; height: 36px; margin-right: 15px; border-radius: 50%; background-color: #333; border: 1px solid var(--border-color); }
        .token-list-item .token-name { font-weight: 600; color: var(--primary-text); font-size: 15px; }
        .token-list-item .token-symbol { font-size: 13px; color: var(--secondary-text); }
        .token-list-item .token-balance { text-align: right; }
        .token-list-item .balance-amount { font-weight: 600; color: var(--primary-text); font-size: 15px; }
        .token-list-item .balance-usd { font-size: 13px; color: var(--secondary-text); margin-top: 2px; }
        .swap-icon { text-align: center; margin: 15px 0; font-size: 28px; cursor: pointer; color: var(--accent-color); transform: rotate(90deg); transition: transform 0.3s ease, color 0.2s ease; }
        .swap-icon:hover { transform: rotate(270deg); color: #ffffff; }
        #swapFeeInfo { font-size: 13px; color: var(--secondary-text); text-align: center; margin-top: -5px; margin-bottom: 20px; min-height: 18px; }
        #swapRate { font-size: 14px; min-height: 20px; margin-bottom: 8px; text-align: center; color: var(--secondary-text);} /* Centered rate */

        /* --- NEW: Token Selector Button Styles --- */
        .token-selector-button {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 12px 18px; /* Consistent with inputs */
            margin-bottom: 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--primary-text);
            font-size: 16px;
            cursor: pointer;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .token-selector-button:hover {
            border-color: var(--secondary-text);
        }
        .token-selector-button .selected-token-info { /* Adjusted name to avoid conflict */
            flex-grow: 1;
            display: flex;
            align-items: center;
            gap: 12px; /* Space between image and text */
        }
        .token-selector-button img {
            width: 28px; /* Slightly smaller than list */
            height: 28px;
            border-radius: 50%;
            background-color: #333;
            border: 1px solid var(--border-color);
        }
        .token-selector-button .token-name-symbol {
            line-height: 1.3;
        }
        .token-selector-button .token-name {
            font-weight: 500;
            font-size: 15px; /* Match list item */
        }
        .token-selector-button .token-symbol {
            font-size: 12px;
            color: var(--secondary-text);
        }
        .token-selector-button .select-prompt {
            color: var(--secondary-text);
            font-style: italic;
        }
        .token-selector-button .dropdown-arrow {
            margin-left: 10px;
            color: var(--secondary-text);
            font-size: 18px;
        }

        /* --- NEW: Token Selector Modal Styles --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-overlay-bg);
            display: flex;
            justify-content: center;
            align-items: flex-end; /* Position modal at bottom */
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease;
        }
        .token-selector-modal {
            background-color: var(--modal-bg);
            width: 100%;
            max-width: 600px; /* Max width on larger screens */
            max-height: 75vh; /* Limit height */
            border-radius: 16px 16px 0 0; /* Rounded top corners */
            display: flex;
            flex-direction: column;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.3);
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }
        .modal-overlay.active .token-selector-modal {
            transform: translateY(0);
        }
        .modal-header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .modal-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
        }
        .modal-close-button {
            background: none;
            border: none;
            color: var(--secondary-text);
            font-size: 24px;
            cursor: pointer;
            line-height: 1;
            padding: 5px;
        }
        .modal-close-button:hover { color: var(--primary-text); }
        .modal-search-container {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .modal-search-input {
            width: 100%;
            padding: 12px 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--primary-text);
            font-size: 15px;
            margin: 0; /* Remove default margin */
        }
        .modal-search-input:focus { outline: none; border-color: var(--accent-color); }
        .modal-token-list {
            list-style: none;
            padding: 0;
            margin: 0;
            overflow-y: auto;
            flex-grow: 1; /* Take remaining space */
        }
        .modal-token-list-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color 0.15s ease;
        }
        .modal-token-list-item:last-child { border-bottom: none; }
        .modal-token-list-item:hover { background-color: var(--hover-bg); }
        .modal-token-list-item .token-info { display: flex; align-items: center; gap: 15px; } /* Same name okay here */
        .modal-token-list-item img { width: 36px; height: 36px; border-radius: 50%; background-color: #333; border: 1px solid var(--border-color); }
        .modal-token-list-item .token-name-symbol { line-height: 1.3; }
        .modal-token-list-item .token-name { font-weight: 600; color: var(--primary-text); font-size: 15px; }
        .modal-token-list-item .token-symbol { font-size: 13px; color: var(--secondary-text); }
        .modal-token-list-item .token-balance { text-align: right; }
        .modal-token-list-item .balance-amount { font-weight: 500; color: var(--primary-text); font-size: 14px; }
        .modal-token-list-item .balance-usd { font-size: 12px; color: var(--secondary-text); margin-top: 2px; }
        .modal-token-list-item.disabled { opacity: 0.5; cursor: not-allowed; }
        .modal-token-list-item.disabled:hover { background-color: transparent; }
        .modal-list-empty {
            padding: 30px 20px;
            text-align: center;
            color: var(--secondary-text);
            font-style: italic;
        }
         /* Swap page specific margin adjustment */
        #swapPage label[for="selectFromTokenBtn"], /* Adjusted labels */
        #swapPage label[for="selectToTokenBtn"] {
            margin-top: 10px;
            display: block; /* Ensure labels take block space */
            margin-bottom: 8px; /* Standard label margin */
        }
        /* Make readonly input look distinct but keep size */
        #toAmount[readonly] {
           background-color: #222; /* Slightly darker input background */
           opacity: 0.7;
           cursor: default;
           border-color: #2a2a2a;
           box-shadow: none;
        }
       #toAmount[readonly]:focus { /* Prevent focus style on read-only */
            outline: none;
            border-color: #2a2a2a;
            box-shadow: none;
        }
       #sendPage label[for="sendAmount"] { margin-top: 10px; } /* Ensure spacing on send page too */
       #sendPage label[for="recipientId"] { margin-top: 5px; }


    </style>
</head>
<body>

    <!-- Blocker -->
    <div id="appBlocker">
         <svg viewBox="0 0 24 24" fill="currentColor" color="#f44336"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1.5 15h-1L7 9h1.5l.8 4h.1l.8-4H12l-2.5 8zm6-1h-1.5l-1.2-4h-.1l-1.2 4H9l2.5-8h1l2.5 8z"></path></svg>
         <h2>Access Denied</h2>
        <p>This application requires access to Telegram user data and can only be launched from within the Telegram app.</p>
        <!-- Add button or further instructions if needed -->
    </div>

    <!-- NEW: Token Selector Modal -->
    <div id="tokenSelectorOverlay" class="modal-overlay">
        <div id="tokenSelectorModal" class="token-selector-modal">
            <div class="modal-header">
                <h3 id="modalTitle">Select Token</h3>
                <button id="modalCloseBtn" class="modal-close-button" aria-label="Close">×</button>
            </div>
            <div class="modal-search-container">
                <input type="text" id="modalSearchInput" class="modal-search-input" placeholder="Search by name or symbol...">
            </div>
            <ul id="modalTokenList" class="modal-token-list">
                <!-- Token items will be populated here -->
                <li class="modal-list-empty">Loading tokens...</li>
            </ul>
        </div>
    </div>


    <div class="app-container">

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="loading-indicator active">Initializing...</div>

        <!-- Global Message Area -->
        <div id="globalMessage" class="message" style="display: none;"></div>

        <!-- Home Page -->
        <div id="homePage" class="page active">
            <h1 id="welcomeMessage">Welcome!</h1>
            <div class="card">
                <h2>Total Balance</h2>
                <div class="balance-display" id="totalBalance">$0.00 <span>USD</span></div>
                <p class="balance-subtitle">Estimated value across all assets</p>
                 <div id="detailedBalances">
                     <h3>Your Assets</h3>
                     <ul id="assetList" style="list-style: none; padding: 0;">
                         <li style="color: var(--secondary-text); text-align: center; padding: 20px 0;">Loading assets...</li>
                     </ul>
                 </div>
            </div>
            <div class="card user-info">
                <h2>Account Info</h2>
                <p><strong>First Name:</strong> <span id="userFirstName">...</span></p>
                <p><strong>Last Name:</strong> <span id="userLastName">...</span></p>
                <p><strong>Username:</strong> <span id="userUsername">...</span></p>
                <p><strong>Chat ID:</strong> <span id="userChatId">...</span></p>
            </div>
             <div class="card transaction-history">
                 <h2>Recent Activity</h2>
                 <ul id="transactionList">
                    <li style="color: var(--secondary-text); text-align: center; border: none; padding: 20px 0;">Loading transactions...</li>
                 </ul>
            </div>
        </div>

        <!-- Swap Page -->
        <div id="swapPage" class="page">
            <h1>Swap Assets</h1>
            <div class="card">
                <div id="swapMessage" class="message" style="display: none;"></div>

                <label for="selectFromTokenBtn">From:</label>
                <!-- Token Selector Button -->
                <button id="selectFromTokenBtn" class="token-selector-button" data-token="">
                    <span class="selected-token-info">
                        <span class="select-prompt">Select Token</span>
                        <!-- Populated by JS -->
                    </span>
                    <span class="dropdown-arrow">▼</span>
                </button>
                <input type="number" id="fromAmount" placeholder="0.0" min="0" step="any" inputmode="decimal">
                <p class="input-helper-text">Balance: <span id="swapFromBalance">0.00</span></p>

                <div class="swap-icon" id="swapDirectionBtn" title="Swap Tokens">⇅</div>

                <label for="selectToTokenBtn">To (Estimated):</label>
                 <!-- Token Selector Button -->
                 <button id="selectToTokenBtn" class="token-selector-button" data-token="">
                    <span class="selected-token-info">
                         <span class="select-prompt">Select Token</span>
                        <!-- Populated by JS -->
                    </span>
                     <span class="dropdown-arrow">▼</span>
                </button>
                <input type="number" id="toAmount" placeholder="0.0" readonly > <!-- Removed inline styles -->
                 <p class="input-helper-text">Balance: <span id="swapToBalance">0.00</span></p>

                <p id="swapRate">Select tokens to see rate</p>
                <p id="swapFeeInfo" style="min-height: 18px;"></p> <!-- Used for Fee and Min Swap Warning -->

                <button id="swapButton" disabled>
                    <svg viewBox="0 0 24 24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg>
                    Swap
                </button>
            </div>
        </div>

        <!-- Receive Page -->
        <div id="depositPage" class="page">
            <h1>Receive Assets</h1>
            <div class="card">
                 <div id="depositMessage" class="message" style="display: none;"></div>
                <p style="color: var(--secondary-text); margin-bottom: 25px; font-size: 14px; text-align: center; line-height: 1.5;">
                    Share your Telegram Chat ID below with other AB Wallet users so they can send assets directly to you.
                </p>

                <h3>Your Telegram Chat ID</h3>
                <div id="depositChatId" class="chat-id-display" title="Click to copy">Loading...</div>
                <div id="copyFeedbackDeposit" class="copy-feedback">Click the ID above to copy</div>

                 <p style="color: var(--secondary-text); font-size: 13px; margin-top: 25px; text-align: center; opacity: 0.8;">
                    <svg viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; vertical-align: middle; margin-right: 5px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                    Only use this ID for receiving assets within this AB Wallet app.
                 </p>
            </div>
        </div>

        <!-- Send Page -->
        <div id="sendPage" class="page">
            <h1>Send Assets</h1>
            <div class="card">
                 <div id="sendMessage" class="message" style="display: none;"></div>

                <label for="selectSendTokenBtn">Asset:</label>
                 <!-- Token Selector Button -->
                 <button id="selectSendTokenBtn" class="token-selector-button" data-token="">
                    <span class="selected-token-info">
                        <span class="select-prompt">Select Asset to Send</span>
                        <!-- Populated by JS -->
                    </span>
                     <span class="dropdown-arrow">▼</span>
                </button>

                <label for="sendAmount">Amount:</label>
                <input type="number" id="sendAmount" placeholder="0.0" min="0" step="any" inputmode="decimal">
                <p class="input-helper-text">
                    <span style="float: left;" id="sendUsdValueInfo">≈ $0.00 USD</span>
                    <span style="float: right;">Available: <strong id="sendAvailableBalance" style="color: var(--primary-text);">0.00</strong></span>
                    <span style="clear: both; display: block;"></span>
                </p>

                <label for="recipientId">Recipient Telegram Chat ID:</label>
                <input type="number" id="recipientId" placeholder="Enter recipient's numeric Chat ID" inputmode="numeric">

                <p style="color: var(--secondary-text); font-size: 13px; margin: 20px 0 10px 0; text-align: center; opacity: 0.8; line-height: 1.5;"> <!-- Adjusted margins/line-height -->
                     <svg viewBox="0 0 24 24" fill="currentColor" style="width: 16px; height: 16px; vertical-align: text-bottom; margin-right: 5px;"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/></svg>
                     Ensure the recipient ID is correct.<br/> Transactions are irreversible.<br/>Minimum send value $${MIN_SEND_USD_VALUE.toFixed(2)}.
                </p>

                <button id="sendButton" disabled>
                    <svg viewBox="0 0 24 24"><path d="M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
                    Send
                </button>
            </div>
        </div>

    </div>

    <!-- Bottom Navigation -->
    <nav class="bottom-nav">
        <button class="nav-item active" data-page="homePage">
            <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8h5z"/></svg>
            Home
        </button>
        <button class="nav-item" data-page="swapPage">
             <svg viewBox="0 0 24 24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg>
            Swap
        </button>
        <button class="nav-item" data-page="depositPage">
             <svg viewBox="0 0 24 24"><path d="M17 13h-4v4h-2v-4H7v-2h4V7h2v4h4v2z M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
            Receive
        </button>
        <button class="nav-item" data-page="sendPage">
             <svg viewBox="0 0 24 24"><path d="M2.01 21 23 12 2.01 3 2 10l15 2-15 2z"></path></svg>
            Send
        </button>
    </nav>

    <script>
          const firebaseConfig = {
            apiKey: "AIzaSyBW1WPXUN8DYhT6npZQYoQ3l4J-jFSbzfg",
            authDomain: "ab-studio-marketcap.firebaseapp.com",
            databaseURL: "https://ab-studio-marketcap-default-rtdb.firebaseio.com",
            projectId: "ab-studio-marketcap",
            storageBucket: "ab-studio-marketcap.appspot.com",
            messagingSenderId: "115268088088",
            appId: "1:115268088088:web:65643a047f92bfaa66ee6d"
        };

        // --- GLOBAL STATE ---
        let currentUser = null;
        let userDbRef = null;
        let db = null;
        let userBalance = {};
        let tokenData = {}; // Will be populated by the real-time listener
        let userTransactions = {};
        let tg = null;
        let firebaseInitialized = false;
        let listenersAttached = false;
        const SWAP_FEE_PERCENT = 0.005; // 0.5% Swap Fee
        const MIN_SEND_USD_VALUE = 0.80; // Minimum send value in USD
        const MIN_SWAP_USD_VALUE = 0.50; // Minimum swap value in USD
        let currentModalContext = null; // Track which button opened the modal ('swap-from', 'swap-to', 'send')

        // --- DOM Elements ---
        const loadingIndicator = document.getElementById('loadingIndicator');
        const globalMessage = document.getElementById('globalMessage');
        const pages = document.querySelectorAll('.page');
        const navItems = document.querySelectorAll('.nav-item');
        const appContainer = document.querySelector('.app-container');
        const appBlocker = document.getElementById('appBlocker');
        // Home Page
        const welcomeMessageEl = document.getElementById('welcomeMessage');
        const totalBalanceEl = document.getElementById('totalBalance');
        const userFirstNameEl = document.getElementById('userFirstName');
        const userLastNameEl = document.getElementById('userLastName');
        const userUsernameEl = document.getElementById('userUsername');
        const userChatIdEl = document.getElementById('userChatId');
        const assetListEl = document.getElementById('assetList');
        const transactionListEl = document.getElementById('transactionList');
        // Swap Page
        const selectFromTokenBtn = document.getElementById('selectFromTokenBtn');
        const selectToTokenBtn = document.getElementById('selectToTokenBtn');
        const fromAmountInput = document.getElementById('fromAmount');
        const toAmountInput = document.getElementById('toAmount');
        const swapButton = document.getElementById('swapButton');
        const swapMessage = document.getElementById('swapMessage');
        const swapRateEl = document.getElementById('swapRate');
        const swapFeeInfoEl = document.getElementById('swapFeeInfo');
        const swapDirectionBtn = document.getElementById('swapDirectionBtn');
        const swapFromBalanceEl = document.getElementById('swapFromBalance');
        const swapToBalanceEl = document.getElementById('swapToBalance');
        // Receive Page
        const depositChatIdEl = document.getElementById('depositChatId');
        const depositMessage = document.getElementById('depositMessage');
        const copyFeedbackDepositEl = document.getElementById('copyFeedbackDeposit');
        // Send Page
        const selectSendTokenBtn = document.getElementById('selectSendTokenBtn');
        const sendAmountInput = document.getElementById('sendAmount');
        const recipientIdInput = document.getElementById('recipientId');
        const sendButton = document.getElementById('sendButton');
        const sendMessage = document.getElementById('sendMessage');
        const sendAvailableBalanceEl = document.getElementById('sendAvailableBalance');
        const sendUsdValueInfoEl = document.getElementById('sendUsdValueInfo');
        // Token Selector Modal Elements
        const tokenSelectorOverlay = document.getElementById('tokenSelectorOverlay');
        const tokenSelectorModal = document.getElementById('tokenSelectorModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalSearchInput = document.getElementById('modalSearchInput');
        const modalTokenList = document.getElementById('modalTokenList');

        // --- UTILITY FUNCTIONS ---
        function showLoading(show, text = 'Loading...') { if (!loadingIndicator) return; loadingIndicator.textContent = text; loadingIndicator.style.display = show ? 'block' : 'none'; loadingIndicator.classList.toggle('active', show); }
        function showMessage(element, message, type = 'error', duration = 5000) { if (!element) return; element.textContent = message; element.className = `message ${type}`; element.style.display = 'block'; if (element.timeoutId) clearTimeout(element.timeoutId); if (duration > 0) { element.timeoutId = setTimeout(() => { element.style.display = 'none'; }, duration); } }
        function showGlobalMessage(message, type = 'error', duration = 5000) { showMessage(globalMessage, message, type, duration); }
        function formatCurrency(amount, decimals = 2) { const num = parseFloat(amount); return isNaN(num) ? '0.00' : num.toLocaleString(undefined, { minimumFractionDigits: decimals, maximumFractionDigits: decimals }); }
        function formatTokenAmount(amount, decimals = 6) { const num = parseFloat(amount); if (isNaN(num)) return '0'; let effectiveDecimals = decimals; if (num > 0) { if (num > 1000) effectiveDecimals = 2; else if (num > 1) effectiveDecimals = 4; else if (num < 0.0001) effectiveDecimals = 8; } else { effectiveDecimals = 2; } effectiveDecimals = Math.min(decimals, effectiveDecimals); return num.toLocaleString(undefined, { minimumFractionDigits: Math.min(2, effectiveDecimals) , maximumFractionDigits: effectiveDecimals }); }
        function triggerHapticFeedback(style = 'medium') { if (tg && tg.HapticFeedback) { try { if (tg.HapticFeedback.impactOccurred) tg.HapticFeedback.impactOccurred(style); else if (tg.HapticFeedback.notificationOccurred) { const type = (style === 'error' || style === 'heavy') ? 'error' : (style === 'success' || style === 'rigid') ? 'success' : 'warning'; tg.HapticFeedback.notificationOccurred(type); } } catch (e) { console.warn("Haptic feedback failed:", e); } } }
        const tinycolor = window.tinycolor || function(color) { // Basic fallback for tinycolor if not loaded
            const isHex = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
             const rgbToHex = (r, g, b) => "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
             let rgb = { r: 0, g: 0, b: 0, a: 1 };
             if (isHex) { rgb = { r: parseInt(isHex[1], 16), g: parseInt(isHex[2], 16), b: parseInt(isHex[3], 16), a: 1 }; }
             // Very basic darken/lighten - NOT accurate perceptually
             const adjust = (amount) => ({
                r: Math.max(0, Math.min(255, Math.round(rgb.r + amount))),
                g: Math.max(0, Math.min(255, Math.round(rgb.g + amount))),
                b: Math.max(0, Math.min(255, Math.round(rgb.b + amount))),
                a: rgb.a
            });
            return {
                 darken: (percent = 10) => { const factor = 1 - (percent / 100); const nr = Math.round(rgb.r * factor); const ng = Math.round(rgb.g * factor); const nb = Math.round(rgb.b * factor); return { toString: () => rgbToHex(nr,ng,nb), ...adjust(0)} }, // Returns another 'tinycolor-like' obj
                 lighten: (percent = 10) => { const factor = 1 + (percent / 100); const nr = Math.min(255,Math.round(rgb.r * factor)); const ng = Math.min(255,Math.round(rgb.g * factor)); const nb = Math.min(255,Math.round(rgb.b * factor)); return { toString: () => rgbToHex(nr,ng,nb), ...adjust(0)} },
                 setAlpha: (a) => ({ toString: () => `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})`, ...adjust(0) }),
                 toString: () => color // return original if not hex or cannot parse
            };
        };
        function applyTheme(params) {
            if (!params) return;
            console.log("Applying theme:", params);
            const root = document.documentElement;
            const setProp = (prop, value) => root.style.setProperty(prop, value);

            try {
                const bgColor = params.bg_color || '#121212';
                const textColor = params.text_color || '#ffffff';
                const hintColor = params.hint_color || '#b3b3b3';
                const linkColor = params.link_color || '#8774e1';
                const buttonColor = params.button_color || '#1DB954';
                const buttonTextColor = params.button_text_color || '#ffffff';
                const secondaryBgColor = params.secondary_bg_color || '#1e1e1e';

                const t_bgColor = tinycolor(bgColor);
                const t_textColor = tinycolor(textColor);
                const t_secondaryBgColor = tinycolor(secondaryBgColor);

                setProp('--bg-color', bgColor);
                setProp('--primary-text', textColor);
                setProp('--secondary-text', hintColor);
                setProp('--link-color', linkColor);
                setProp('--button-bg', buttonColor);
                setProp('--button-text', buttonTextColor);
                setProp('--accent-color', buttonColor);
                setProp('--card-bg', secondaryBgColor);
                setProp('--input-bg', t_secondaryBgColor.darken(5).toString());
                setProp('--border-color', t_secondaryBgColor.lighten(10).toString());
                setProp('--hover-bg', t_textColor.setAlpha(0.05).toString());
                setProp('--receive-color', '#4caf50'); // Keep standard transaction colors
                setProp('--send-color', '#f44336');
                setProp('--swap-color', '#ff9800');
                setProp('--warning-color', '#ffa726');
                setProp('--modal-bg', t_bgColor.lighten(5).toString());
                setProp('--modal-overlay-bg', t_bgColor.setAlpha(0.7).toString());

                // Update body directly
                document.body.style.backgroundColor = bgColor;
                document.body.style.color = textColor;

                // Update Telegram UI components if available
                if (tg && tg.setHeaderColor) try { tg.setHeaderColor(secondaryBgColor); } catch(e) { console.warn("Failed to set header color", e);}
                if (tg && tg.setBackgroundColor) try { tg.setBackgroundColor(bgColor); } catch(e) { console.warn("Failed to set background color", e);}

                console.log("Theme applied successfully");

            } catch (error) {
                 console.error("Error applying theme:", error);
                 // Fallback to defaults if tinycolor or params fail badly
                const root = document.documentElement;
                const setProp = (prop, value) => root.style.setProperty(prop, value);
                setProp('--bg-color', '#121212'); setProp('--primary-text', '#ffffff'); setProp('--secondary-text', '#b3b3b3'); setProp('--card-bg', '#1e1e1e'); setProp('--accent-color', '#1DB954'); setProp('--button-bg', '#1DB954'); setProp('--button-text', '#ffffff'); setProp('--input-bg', '#282828'); setProp('--border-color', '#333333'); setProp('--modal-bg', '#2a2a2a'); setProp('--modal-overlay-bg', 'rgba(0,0,0,0.7)');
                document.body.style.backgroundColor = '#121212'; document.body.style.color = '#ffffff';
            }
        }


        // --- PAGE NAVIGATION ---
        function showPage(pageId) {
            const targetPage = document.getElementById(pageId);
             if (!targetPage) { console.error("Page not found:", pageId); showGlobalMessage(`Error: Page ${pageId} does not exist.`, 'error'); return; }
            pages.forEach(page => page.classList.remove('active'));
            targetPage.classList.add('active');
            navItems.forEach(item => { item.classList.toggle('active', item.dataset.page === pageId); });
            if (appContainer) appContainer.scrollTop = 0; // Scroll to top of new page
            // Hide previous page-specific messages
            if (swapMessage) swapMessage.style.display = 'none';
            if (depositMessage) depositMessage.style.display = 'none';
            if (sendMessage) sendMessage.style.display = 'none';

             // Trigger UI updates for the activated page if needed (data might have changed)
             switch(pageId) {
                 case 'homePage': updateHomePageUI(); break;
                 case 'swapPage': if (tokenData && Object.keys(tokenData).length > 0) updateSwapUI(); break;
                 case 'sendPage': if (userBalance && Object.keys(userBalance).length > 0 && tokenData) updateSendForm(); break;
                 case 'depositPage': updateDepositPageUI(); break;
             }
             console.log(`Navigated to page: ${pageId}`);
         }

        // --- FIREBASE FUNCTIONS ---
        function initializeFirebase() { return new Promise((resolve, reject) => { if (firebaseInitialized) { resolve(); return; } try { if (typeof firebase === 'undefined' || !firebase.app || !firebase.database) { throw new Error("Firebase SDK not loaded correctly."); } if (!firebase.apps.length) { firebase.initializeApp(firebaseConfig); console.log("Firebase Initialized"); } else { firebase.app(); console.log("Firebase Re-using existing app instance."); } db = firebase.database(); firebaseInitialized = true; resolve(); } catch (error) { console.error("Firebase Initialization Error:", error); showGlobalMessage("Error connecting to database services. Please try again later.", "error", 0); reject(error); } }); }

        // --- REMOVED OLD getTokenData FUNCTION ---

        // --- NEW: Real-time Listener for Token Data ---
        function listenForTokenData() {
            if (!db) return Promise.reject("Database not available for fetching token data.");
            const tokensRef = db.ref('tokens');

            console.log("Setting up real-time listener for /tokens");

            tokensRef.on('value', (snapshot) => {
                const newTokens = snapshot.val() || {};
                console.log("Real-time token data received:", newTokens);

                // Ensure USDT base token exists with price 1.00
                if (newTokens.USDT) {
                    newTokens.USDT.priceUSD = 1.00; // Always enforce USDT = 1
                } else {
                    // Add USDT if it's missing entirely
                    console.warn("USDT token data missing from Firebase, adding default.");
                    newTokens.USDT = { name: "Tether USD", priceUSD: 1.00, logoUrl: "https://via.placeholder.com/32/26A17B/ffffff?text=USDT" };
                }

                // Validate price data - convert to float, default to 0 if invalid
                for (const symbol in newTokens) {
                     if (typeof newTokens[symbol] === 'object' && newTokens[symbol] !== null) { // Check if it's an object before accessing properties
                        const price = parseFloat(newTokens[symbol].priceUSD);
                        newTokens[symbol].priceUSD = (!isNaN(price) && price >= 0) ? price : 0;
                         if (symbol === 'USDT') newTokens[symbol].priceUSD = 1.00; // Re-ensure USDT price is 1
                     } else {
                         console.warn(`Invalid data structure for token ${symbol}:`, newTokens[symbol]);
                         // Optionally remove invalid entry or provide defaults
                         delete newTokens[symbol]; // Example: remove it
                     }
                }


                // Update global tokenData state
                tokenData = newTokens;

                // Trigger UI updates immediately after prices change
                console.log("Token data updated, refreshing relevant UI sections.");
                updateHomePageUI();   // Recalculates total balance, asset values
                updateSwapUI();     // Recalculates rates, output amount, balances
                updateSendForm();   // Recalculates USD value estimate, balances
                 // If the modal is open, refresh its list
                 if (tokenSelectorOverlay.classList.contains('active')) {
                    populateTokenList();
                 }

            }, (error) => {
                // Error handler for the listener
                console.error("Firebase Token Listener Error:", error);
                showGlobalMessage("Error receiving live price updates. Displayed prices may be outdated.", "warning", 10000);
                triggerHapticFeedback('error');
                // Ensure a default USDT exists if the listener fails initially or ongoingly
                if (!tokenData.USDT) {
                    tokenData = { USDT: { name: "Tether USD", priceUSD: 1.00, logoUrl: "https://via.placeholder.com/32/26A17B/ffffff?text=USDT" } };
                     updateHomePageUI(); // Update UI with at least USDT
                     updateSwapUI();
                     updateSendForm();
                }
            });

            // Return a promise that resolves when the *first* data is received
            // This helps ensure initial dependent steps have some data to work with
            return new Promise((resolve, reject) => {
                tokensRef.once('value', snapshot => {
                     let initialTokens = snapshot.val() || {};
                     // Ensure USDT base token exists with price 1.00 on initial load
                     if (initialTokens.USDT) {
                         initialTokens.USDT.priceUSD = 1.00;
                     } else {
                         initialTokens.USDT = { name: "Tether USD", priceUSD: 1.00, logoUrl: "https://via.placeholder.com/32/26A17B/ffffff?text=USDT" };
                     }
                      // Initial price validation
                      for (const symbol in initialTokens) {
                          if (typeof initialTokens[symbol] === 'object' && initialTokens[symbol] !== null) {
                             const price = parseFloat(initialTokens[symbol].priceUSD);
                             initialTokens[symbol].priceUSD = (!isNaN(price) && price >= 0) ? price : 0;
                             if (symbol === 'USDT') initialTokens[symbol].priceUSD = 1.00;
                         } else {
                             console.warn(`Invalid initial data structure for token ${symbol}:`, initialTokens[symbol]);
                              delete initialTokens[symbol];
                          }
                      }
                      tokenData = initialTokens; // Set initial validated data immediately
                     console.log("Initial token data fetched successfully.", tokenData);
                     resolve();
                }, error => {
                     console.error("Failed to fetch initial token data:", error);
                     showGlobalMessage("Failed to load initial token prices.", "error", 5000);
                     // Provide minimal default even on initial failure
                     tokenData = { USDT: { name: "Tether USD", priceUSD: 1.00, logoUrl: "https://via.placeholder.com/32/26A17B/ffffff?text=USDT" } };
                     // Rejecting might stop init, consider resolving with default if non-critical
                     // reject(error);
                     resolve(); // Resolve even with default so app can potentially continue
                });
            });
        }

        async function performSwapTransaction(userId, updates, txRecord) { if (!db || !userId) return Promise.reject("Database or UserID not available for swap."); userId = String(userId); const multiPathUpdate = {}; for (const asset in updates) { const updateValue = parseFloat(updates[asset]); if (isNaN(updateValue)) { throw new Error(`Invalid update value for asset ${asset}: ${updates[asset]}`); } multiPathUpdate[`/users/${userId}/balances/${asset}`] = firebase.database.ServerValue.increment(updateValue); } const txRef = db.ref(`users/${userId}/transactions`).push(); multiPathUpdate[`/users/${userId}/transactions/${txRef.key}`] = { ...txRecord, timestamp: firebase.database.ServerValue.TIMESTAMP }; console.log("Attempting Atomic Swap Update:", JSON.stringify(multiPathUpdate, null, 2)); return db.ref().update(multiPathUpdate); }
        async function performP2PTransfer(senderId, recipientId, asset, amount) { senderId = String(senderId); recipientId = String(recipientId); amount = parseFloat(amount); if (!db || !senderId || !recipientId || !asset || isNaN(amount) || amount <= 0) { return Promise.reject("Invalid parameters for transfer."); } if (senderId === recipientId) { return Promise.reject("Cannot send assets to yourself."); } const recipientRef = db.ref(`users/${recipientId}`); const recipientSnapshot = await recipientRef.once('value'); if (!recipientSnapshot.exists()) { const error = new Error(`Recipient with Chat ID ${recipientId} not found or has not used the wallet yet.`); error.code = "RECIPIENT_NOT_FOUND"; throw error; } const senderTxRef = db.ref(`users/${senderId}/transactions`).push(); const recipientTxRef = db.ref(`users/${recipientId}/transactions`).push(); const multiPathUpdate = {}; multiPathUpdate[`/users/${senderId}/balances/${asset}`] = firebase.database.ServerValue.increment(-amount); multiPathUpdate[`/users/${recipientId}/balances/${asset}`] = firebase.database.ServerValue.increment(amount); multiPathUpdate[`/users/${senderId}/transactions/${senderTxRef.key}`] = { type: "send", asset: asset, amount: amount, toUserId: recipientId, status: "completed", timestamp: firebase.database.ServerValue.TIMESTAMP, recipientTxKey: recipientTxRef.key }; multiPathUpdate[`/users/${recipientId}/transactions/${recipientTxRef.key}`] = { type: "receive", asset: asset, amount: amount, fromUserId: senderId, status: "completed", timestamp: firebase.database.ServerValue.TIMESTAMP, senderTxKey: senderTxRef.key }; console.log("Attempting Atomic P2P Update:", JSON.stringify(multiPathUpdate, null, 2)); return db.ref().update(multiPathUpdate); }

        // Modify getUserDataRealtime for initial balance
        function getUserDataRealtime(userId) {
            if (!db || !userId) return Promise.reject("Database or UserID not available for real-time updates.");
             if (userDbRef) { // Detach previous listener if re-initializing
                 console.log("Detaching previous user data listener.");
                 userDbRef.off();
             }
            userDbRef = db.ref(`users/${userId}`);
            return new Promise((resolve, reject) => {
                let initialDataLoaded = false;
                console.log(`Setting up listener for user ${userId}`);
                userDbRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    console.log(`Real-time data received for user ${userId}:`, data ? 'Exists' : 'Does not exist');

                    if (data) {
                        userBalance = data.balances || {};
                        userTransactions = data.transactions || {};
                        // Ensure critical UIs update with new balance/tx data
                        updateHomePageUI();
                        updateSwapUI(); // Balances affect swap page
                        updateSendForm(); // Balances affect send form

                        if (!initialDataLoaded) { initialDataLoaded = true; console.log("Initial user data loaded."); resolve(data); }
                    } else if (currentUser && userId === String(currentUser.id) && !initialDataLoaded) {
                         console.log("User not found in DB, creating entry with initial balance...");
                         const { id, first_name, last_name, username } = currentUser;
                         const initialUserData = {
                             chatId: String(id),
                             firstName: first_name || '', lastName: last_name || '', username: username || 'N/A',
                             joinedAt: firebase.database.ServerValue.TIMESTAMP,
                             balances: { USDT: 0.1 }, // NEW: Initial balance 0.1 USDT
                             transactions: {}
                         };
                         userDbRef.set(initialUserData)
                            .then(() => {
                                console.log("Initial user data created successfully.");
                                userBalance = initialUserData.balances;
                                userTransactions = initialUserData.transactions;
                                updateHomePageUI(); // Update UI with initial data
                                updateSendForm();
                                updateSwapUI();
                                initialDataLoaded = true; // Mark as loaded
                                resolve(initialUserData); // Resolve the promise
                            })
                            .catch(err => {
                                console.error("Failed to create initial user data:", err);
                                showGlobalMessage("Error setting up your wallet account.", "error", 0);
                                if (!initialDataLoaded) reject(err); // Reject only if it fails initially
                            });
                    } else if (!initialDataLoaded && !snapshot.exists()) {
                         // This case should ideally be handled by the creation block above
                         console.warn(`User data for ID ${userId} not found, and creation didn't trigger (or happened before listener). Resolving null.`);
                          if (!initialDataLoaded) resolve(null); // Resolve null if definitely not found initially
                     }
                }, (error) => {
                    console.error(`Firebase Read Error for user ${userId}:`, error);
                    showGlobalMessage("Database connection error. Displayed data might be outdated.", "error", 5000);
                    triggerHapticFeedback('error');
                    if (!initialDataLoaded) reject(error); // Reject if the *initial* connection fails
                });
            });
        }

        // --- UI UPDATE FUNCTIONS ---
        function updateHomePageUI() {
            // console.log("Updating Home Page UI. User:", currentUser, "Balance:", userBalance, "Tokens:", tokenData);
            if (!currentUser || !welcomeMessageEl) return;
            welcomeMessageEl.textContent = `Welcome, ${currentUser.first_name || 'User'}!`;
            userFirstNameEl.textContent = currentUser.first_name || '-';
            userLastNameEl.textContent = currentUser.last_name || '-';
            userUsernameEl.textContent = currentUser.username ? `@${currentUser.username}` : '(No username)';
            userChatIdEl.textContent = currentUser.id || 'N/A';

            let totalUsdValue = 0;
            assetListEl.innerHTML = ''; // Clear current list
            const sortedBalances = Object.entries(userBalance)
                .map(([asset, balance]) => ({
                    asset,
                    balance: parseFloat(balance || 0),
                    tokenInfo: tokenData[asset], // Get token info using current tokenData
                    priceUsd: parseFloat(tokenData[asset]?.priceUSD || (asset === 'USDT' ? 1 : 0)) // Use current prices
                 }))
                 .filter(item => item.balance > 0.000001 || item.asset === 'USDT') // Keep USDT even if zero balance
                .map(item => ({ ...item, usdValue: item.balance * item.priceUsd }))
                .sort((a, b) => {
                     if (b.usdValue !== a.usdValue) return b.usdValue - a.usdValue; // Sort by USD value first
                    const nameA = a.tokenInfo?.name || a.asset;
                    const nameB = b.tokenInfo?.name || b.asset;
                     return nameA.localeCompare(nameB); // Then alphabetically by name
                 });

            if (sortedBalances.length === 0) {
                 assetListEl.innerHTML = '<li style="color: var(--secondary-text); text-align: center; padding: 20px 0;">You have no assets yet. Try swapping or receiving.</li>';
            } else {
                 sortedBalances.forEach(item => {
                    totalUsdValue += item.usdValue;
                    const li = document.createElement('li');
                    li.className = 'token-list-item';
                     const logoUrl = item.tokenInfo?.logoUrl || `https://via.placeholder.com/36/333333/ffffff?text=${item.asset.substring(0,1)}`;
                     const name = item.tokenInfo?.name || item.asset;
                    li.innerHTML = `
                        <div class="token-info">
                             <img src="${logoUrl}" alt="${item.asset}" onerror="this.src='https://via.placeholder.com/36/333333/ffffff?text=${item.asset.substring(0,1)}'; this.onerror=null;">
                            <div>
                                <div class="token-name">${name}</div>
                                <div class="token-symbol">${item.asset}</div>
                            </div>
                        </div>
                        <div class="token-balance">
                            <div class="balance-amount">${formatTokenAmount(item.balance, 8)}</div>
                            ${(item.usdValue > 0.01 || item.asset === 'USDT') ? `<div class="balance-usd">≈ $${formatCurrency(item.usdValue)}</div>` : ''}
                        </div>
                    `;
                    assetListEl.appendChild(li);
                });
             }
             // Ensure USDT is shown if balance is 0 but tokenData exists for it
             if (userBalance.USDT == null || parseFloat(userBalance.USDT) <= 0.000001 && tokenData.USDT && !sortedBalances.some(item => item.asset === 'USDT')) {
                 const li = document.createElement('li');
                 li.className = 'token-list-item';
                  li.style.opacity = '0.7'; // Indicate zero balance visually
                 const logoUrl = tokenData.USDT.logoUrl || `https://via.placeholder.com/36/26A17B/ffffff?text=U`;
                 li.innerHTML = `
                     <div class="token-info">
                         <img src="${logoUrl}" alt="USDT" onerror="this.src='https://via.placeholder.com/36/333333/ffffff?text=U'; this.onerror=null;">
                         <div>
                             <div class="token-name">${tokenData.USDT.name || 'Tether USD'}</div>
                             <div class="token-symbol">USDT</div>
                         </div>
                     </div>
                     <div class="token-balance">
                         <div class="balance-amount">0.00</div>
                         <div class="balance-usd">≈ $0.00</div>
                     </div>
                 `;
                 assetListEl.appendChild(li); // Add USDT item at the end if not already present
             }


            totalBalanceEl.innerHTML = `$${formatCurrency(totalUsdValue)} <span>USD</span>`;
            updateTransactionHistory(); // Also update tx history
        }
        function updateTransactionHistory() {
            if (!transactionListEl) return;
            transactionListEl.innerHTML = ''; // Clear current list

             const txArray = Object.entries(userTransactions || {})
                .map(([key, value]) => ({ id: key, ...value }))
                 .sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0)); // Sort newest first

            if (txArray.length === 0) {
                transactionListEl.innerHTML = '<li style="color: var(--secondary-text); text-align: center; border: none; padding: 20px 0;">No transaction history.</li>';
                return;
             }

             txArray.slice(0, 30).forEach(tx => { // Limit to last 30 transactions
                const li = document.createElement('li');
                li.classList.add(tx.type || 'unknown');

                 let iconSvg = '';
                 let mainInfoHtml = '';
                 let peerInfoHtml = '';
                 // Safely access potentially missing amount/asset fields
                 const amount = tx.amount || tx.fromAmount || 0;
                 const asset = tx.asset || tx.fromAsset || '?';
                 const toAmount = tx.toAmount; // Will be undefined for non-swap tx
                 const toAsset = tx.toAsset;

                 const amountFormatted = formatTokenAmount(amount, 8);
                 const assetSymbol = asset;
                 const toAmountFormatted = toAmount ? formatTokenAmount(toAmount, 8) : '';
                 const toAssetSymbol = toAsset || '';


                 switch (tx.type) {
                     case 'receive':
                         iconSvg = `<svg class="tx-type-icon" style="color: var(--receive-color);" viewBox="0 0 24 24" fill="currentColor"><path d="M11 15h2v-4h4v-2h-4V5h-2v4H7v2h4v4zm1-13C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>`;
                         mainInfoHtml = `Received <span class="tx-amount">${amountFormatted}</span> <span class="tx-asset">${assetSymbol}</span>`;
                         peerInfoHtml = `<span class="tx-peer">From: <strong>${tx.fromUserId || 'Unknown Source'}</strong></span>`;
                         break;
                     case 'send':
                         iconSvg = `<svg class="tx-type-icon" style="color: var(--send-color);" viewBox="0 0 24 24" fill="currentColor"><path d="M3.4 20.4l17.4-8.4c.7-.3.7-1.2 0-1.5L3.4 2.1c-.6-.3-1.3.1-1.3.8l.9 6.5c0 .5.5.9 1 .9h6.4c.4 0 .6.5.3.8l-2.6 2.1c-.4.3-.4.9 0 1.2l2.6 2.1c.3.3.1.8-.3.8H4c-.5 0-1 .4-1 .9l-.9 6.5c0 .6.7 1.1 1.3.8z"></path></svg>`;
                         mainInfoHtml = `Sent <span class="tx-amount">${amountFormatted}</span> <span class="tx-asset">${assetSymbol}</span>`;
                         peerInfoHtml = `<span class="tx-peer">To: <strong>${tx.toUserId || 'Unknown Destination'}</strong></span>`;
                         break;
                     case 'swap':
                         iconSvg = `<svg class="tx-type-icon" style="color: var(--swap-color);" viewBox="0 0 24 24" fill="currentColor"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg>`;
                         // Ensure both amounts/assets exist for the message
                         if (amountFormatted && assetSymbol && toAmountFormatted && toAssetSymbol) {
                              mainInfoHtml = `Swapped <span class="tx-amount">${amountFormatted} ${assetSymbol}</span> for <span class="tx-amount">${toAmountFormatted} ${toAssetSymbol}</span>`;
                         } else {
                              mainInfoHtml = `Swap Processed`; // Fallback message
                         }
                         if (tx.effectiveRate && tx.fromAsset && tx.toAsset) {
                              peerInfoHtml = `<span class="tx-peer">Rate: ≈ ${formatTokenAmount(tx.effectiveRate, 5)} ${tx.toAsset}/${tx.fromAsset}</span>`;
                         } else {
                             peerInfoHtml = `<span class="tx-peer">Details processing</span>`; // More specific fallback
                         }
                         break;
                     default:
                         iconSvg = `<svg class="tx-type-icon" style="color: var(--secondary-text);" viewBox="0 0 24 24" fill="currentColor"><path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"/></svg>`;
                         mainInfoHtml = `System: <span class="tx-amount">${amountFormatted}</span> <span class="tx-asset">${assetSymbol || 'N/A'}</span>`;
                         peerInfoHtml = `<span class="tx-peer">Type: ${tx.type || 'Unknown'}</span>`;
                }

                 const timestampStr = tx.timestamp ? new Date(tx.timestamp).toLocaleString([], { day: '2-digit', month: 'short', hour: '2-digit', minute:'2-digit', hour12: false }) : 'Pending...';
                 // Ensure tx.id exists before creating the span
                 const txIdHtml = tx.id ? `<span class="tx-id" title="Click to copy Tx ID: ${tx.id}" onclick="copyTextToClipboard('${tx.id}', 'Transaction ID')">TxID: ${tx.id.substring(0, 6)}...${tx.id.substring(tx.id.length - 4)}</span>` : '';

                 li.innerHTML = `
                     <div class="tx-details">
                         ${iconSvg}
                         <div class="tx-main-info">
                             ${mainInfoHtml}
                             ${peerInfoHtml}
                             ${txIdHtml}
                         </div>
                     </div>
                     <div class="tx-timestamp">${timestampStr}</div>
                `;
                transactionListEl.appendChild(li);
            });
         }

        // --- Token Modal Functions ---
        function openTokenSelector(context) {
            currentModalContext = context; // 'swap-from', 'swap-to', 'send'
            modalSearchInput.value = ''; // Clear search on open
            populateTokenList(); // Populate based on context and current selections
            modalTitle.textContent = context === 'send' ? 'Select Asset to Send' : 'Select Token';
            tokenSelectorOverlay.classList.add('active');
            // Focus input after animation starts to prevent jarring shift
            setTimeout(() => { try { modalSearchInput.focus(); } catch (e) { console.warn("Could not focus modal search input:", e)} }, 50);
            // Prevent body scrolling while modal is open
             document.body.style.overflow = 'hidden';
            console.log(`Opened token selector for context: ${context}`);
        }

        function closeTokenSelector() {
            tokenSelectorOverlay.classList.remove('active');
            // Restore body scrolling after animation finishes
            setTimeout(() => { document.body.style.overflow = ''; }, 300);
             console.log("Closed token selector.");
        }

        function populateTokenList() {
            if (!modalTokenList) return; // Guard clause
            modalTokenList.innerHTML = ''; // Clear previous list

            const searchTerm = modalSearchInput.value.toLowerCase().trim();

             // Create a usable array of tokens from the tokenData object
             let tokensToShow = Object.entries(tokenData)
                 .map(([symbol, data]) => ({ symbol, ...data })) // Convert to array of objects
                 .filter(token => token && token.symbol && typeof token.priceUSD === 'number'); // Basic data validation

            // For 'send', filter by assets the user actually owns > epsilon
             if (currentModalContext === 'send') {
                 tokensToShow = tokensToShow.filter(token => {
                     const balance = parseFloat(userBalance[token.symbol] || 0);
                     return balance > 0.0000001; // Only show assets with some non-dust balance
                 });
             }

             // Filter by search term (name or symbol)
             if (searchTerm) {
                 tokensToShow = tokensToShow.filter(token =>
                     token.symbol.toLowerCase().includes(searchTerm) ||
                     (token.name || '').toLowerCase().includes(searchTerm)
                 );
             }

             // Sort tokens: Prioritize USDT, then sort alphabetically by name/symbol
            tokensToShow.sort((a, b) => {
                if (a.symbol === 'USDT') return -1; // USDT first
                if (b.symbol === 'USDT') return 1;
                const nameA = a.name || a.symbol;
                 const nameB = b.name || b.symbol;
                 return nameA.localeCompare(nameB); // Alphabetical after USDT
            });


            if (tokensToShow.length === 0) {
                modalTokenList.innerHTML = `<li class="modal-list-empty">${searchTerm ? 'No matching tokens found.' : 'No tokens available.'}</li>`;
                return;
             }

             // Get currently selected tokens to disable them in the list if needed
            const selectedFromToken = selectFromTokenBtn.dataset.token;
            const selectedToToken = selectToTokenBtn.dataset.token;
            const selectedSendToken = selectSendTokenBtn.dataset.token; // Used on send page

             tokensToShow.forEach(token => {
                const symbol = token.symbol;
                 const data = token; // token is already the combined object

                const li = document.createElement('li');
                li.className = 'modal-token-list-item';
                li.dataset.symbol = symbol;

                const balance = parseFloat(userBalance[symbol] || 0);
                const priceUsd = data.priceUSD; // Already validated number
                const balanceUsdValue = balance * priceUsd;

                 let balanceHtml = '';
                 // Show balance only for 'send' or possibly other relevant contexts if added later
                 // Or maybe always show balance? Decide based on UI preference. Let's show always for now.
                 balanceHtml = `
                     <div class="token-balance">
                         <div class="balance-amount">${formatTokenAmount(balance, 8)}</div>
                         ${balanceUsdValue > 0.01 || symbol === 'USDT' ? `<div class="balance-usd">≈ $${formatCurrency(balanceUsdValue)}</div>` : ''}
                     </div>
                 `;
                 // If only for send:
                 // if (currentModalContext === 'send') {
                 //     balanceHtml = ...
                 // }

                 const logoUrl = data.logoUrl || `https://via.placeholder.com/36/333333/ffffff?text=${symbol.substring(0,1)}`;
                li.innerHTML = `
                    <div class="token-info">
                        <img src="${logoUrl}" alt="${symbol}" onerror="this.src='https://via.placeholder.com/36/333333/ffffff?text=${symbol.substring(0,1)}'; this.onerror=null;">
                        <div class="token-name-symbol">
                            <div class="token-name">${data.name || symbol}</div>
                            <div class="token-symbol">${symbol}</div>
                        </div>
                    </div>
                    ${balanceHtml}
                `;

                // --- Disable logic ---
                 let isDisabled = false;
                let disabledReason = '';
                // On SWAP page: disable if the token is selected in the OTHER slot
                if (currentModalContext === 'swap-from' && symbol === selectedToToken && selectedToToken) { isDisabled = true; disabledReason="Selected in 'To' slot"; }
                 if (currentModalContext === 'swap-to' && symbol === selectedFromToken && selectedFromToken) { isDisabled = true; disabledReason="Selected in 'From' slot"; }
                 // Also disable if token has zero balance and context is SEND
                 if (currentModalContext === 'send' && balance <= 0.0000001) { isDisabled = true; disabledReason="Zero balance"; }


                 if (isDisabled) {
                     li.classList.add('disabled');
                     li.title = disabledReason || "Cannot select this token";
                 } else {
                    // Check if clicking the currently selected token in the *same* slot (mostly cosmetic, avoids re-selection noise)
                    let isCurrentlySelected = false;
                     if (currentModalContext === 'swap-from' && symbol === selectedFromToken) isCurrentlySelected = true;
                     if (currentModalContext === 'swap-to' && symbol === selectedToToken) isCurrentlySelected = true;
                     if (currentModalContext === 'send' && symbol === selectedSendToken) isCurrentlySelected = true;

                     if (isCurrentlySelected) {
                         li.style.opacity = '0.6'; // Visually indicate it's already selected
                          li.title = "Already selected";
                     }
                    li.addEventListener('click', () => handleTokenSelection(symbol));
                 }


                modalTokenList.appendChild(li);
             });
        }

        function handleTokenSelection(symbol) {
             console.log(`Token selected: ${symbol} for context: ${currentModalContext}`);
             const token = tokenData[symbol];
             if (!token) { console.error(`Data for selected token ${symbol} not found.`); return; }

             // Determine which button to update
            let targetButton;
             if (currentModalContext === 'swap-from') targetButton = selectFromTokenBtn;
            else if (currentModalContext === 'swap-to') targetButton = selectToTokenBtn;
             else if (currentModalContext === 'send') targetButton = selectSendTokenBtn;
            else { console.error("Invalid modal context:", currentModalContext); return; }

             // Avoid unnecessary updates if the same token is selected again
             if (targetButton.dataset.token === symbol) {
                 closeTokenSelector();
                 return; // Don't proceed if it's the same token
             }


             // Update the button appearance and data attribute
            targetButton.dataset.token = symbol;
            const infoSpan = targetButton.querySelector('.selected-token-info');
             const logoUrl = token.logoUrl || `https://via.placeholder.com/36/333333/ffffff?text=${symbol.substring(0,1)}`;
            infoSpan.innerHTML = `
                 <img src="${logoUrl}" alt="${symbol}" onerror="this.src='https://via.placeholder.com/36/333333/ffffff?text=${symbol.substring(0,1)}'; this.onerror=null;">
                 <div class="token-name-symbol">
                     <div class="token-name">${token.name || symbol}</div>
                     <div class="token-symbol">${symbol}</div>
                 </div>
             `;

             closeTokenSelector();
             triggerHapticFeedback('light');

             // Trigger UI update for the relevant page section
             if (currentModalContext.startsWith('swap')) {
                updateSwapUI(); // Update rates, balances, button state etc.
             } else if (currentModalContext === 'send') {
                 updateSendForm(); // Update available balance, USD value etc.
                 sendAmountInput.focus(); // Focus amount input after selecting asset
            }
        }


        // --- UPDATE UI Functions (Relies on Global State: tokenData, userBalance) ---

        function updateSwapUI() {
             // Ensure elements and data are ready
             if (!selectFromTokenBtn || !selectToTokenBtn || !fromAmountInput || !toAmountInput || !swapFromBalanceEl || !swapToBalanceEl || !swapButton || !tokenData) {
                  // console.warn("Swap UI update skipped, elements or token data not ready.");
                 return;
             }
             // console.log("Updating Swap UI..."); // Debug log

             // Get selected tokens from button data attributes
             const fromAsset = selectFromTokenBtn.dataset.token || null;
             const toAsset = selectToTokenBtn.dataset.token || null;

            const fromAmount = Math.max(0, parseFloat(fromAmountInput.value || 0));
            const fromBalance = parseFloat(userBalance[fromAsset] || 0);
            const toBalance = parseFloat(userBalance[toAsset] || 0);

             // Update balance displays
            swapFromBalanceEl.textContent = fromAsset ? `${formatTokenAmount(fromBalance, 8)} ${fromAsset}` : 'N/A';
            swapToBalanceEl.textContent = toAsset ? `${formatTokenAmount(toBalance, 8)} ${toAsset}` : 'N/A';

             // --- Calculate and Display Rate & To Amount ---
            updateSwapRateAndToAmount(); // This function now handles setting rate, fee, and toAmount input value

             // --- Validation for Swap Button ---
             const calculatedToAmount = parseFloat(toAmountInput.value || 0); // Read the calculated value
             const hasSufficientBalance = fromBalance >= fromAmount;
             const isValidAmount = fromAmount > 0;
             const areTokensSelected = fromAsset && toAsset;
             const areTokensDifferent = fromAsset !== toAsset;
             // Consider rate "available" if token prices are valid > 0
             const arePricesAvailable = fromAsset && toAsset && tokenData[fromAsset] && tokenData[toAsset] && tokenData[fromAsset].priceUSD > 0 && tokenData[toAsset].priceUSD > 0;

             // Minimum Swap Value Check
             let meetsMinValue = true;
             let minSwapWarning = '';
             let fromAmountUsdValue = 0;
             if (isValidAmount && fromAsset && tokenData[fromAsset] && tokenData[fromAsset].priceUSD > 0) {
                 const priceUsd = tokenData[fromAsset].priceUSD;
                 fromAmountUsdValue = fromAmount * priceUsd;
                 if (fromAmountUsdValue < MIN_SWAP_USD_VALUE) {
                     meetsMinValue = false;
                     minSwapWarning = `Min swap value ≈ $${formatCurrency(MIN_SWAP_USD_VALUE)}.`;
                 }
             }

             // Update Combined Fee and Min Value Info display (handled within updateSwapRateAndToAmount, but double check logic here)
             const feePercentDisplay = (SWAP_FEE_PERCENT * 100).toFixed(2) + '%';
             let feeInfoText = arePricesAvailable ? `Fee: ${feePercentDisplay}. ` : 'Fee calculation requires valid prices. ';
             if (!meetsMinValue) {
                 feeInfoText += minSwapWarning;
                 swapFeeInfoEl.classList.add('warning'); // Style the warning
             } else {
                 swapFeeInfoEl.classList.remove('warning');
             }
             // Ensure fee/min text is set, even if empty (handled in updateSwapRateAndToAmount)
              if (swapFeeInfoEl.textContent.trim() === '' && areTokensSelected) {
                 swapFeeInfoEl.textContent = feeInfoText;
              }


            // Final enablement check
             const canSwap = areTokensSelected &&
                            areTokensDifferent &&
                            isValidAmount &&
                            hasSufficientBalance &&
                            arePricesAvailable && // Check if prices allow calculation
                            meetsMinValue; // Add min value check

             swapButton.disabled = !canSwap;

             // Provide specific feedback if button is disabled
             if (swapButton.disabled && areTokensSelected && areTokensDifferent && isValidAmount) {
                 if (!hasSufficientBalance) {
                      // Show persistent message only if not already handled by helper text warning
                      if(!swapFeeInfoEl.textContent.includes("Insufficient")){ // Avoid duplicate messages
                         // Consider not showing a message if helper text already clear?
                          // showMessage(swapMessage, `Insufficient ${fromAsset} balance`, 'error', 4000);
                      }
                     fromAmountInput.style.borderColor = 'var(--error-color)'; // Highlight the input
                     swapFromBalanceEl.style.color = 'var(--error-color)';
                 } else {
                    fromAmountInput.style.borderColor = ''; // Reset border
                    swapFromBalanceEl.style.color = ''; // Reset color
                 }
                if (!meetsMinValue && swapFeeInfoEl.textContent.includes('Min swap')) {
                     // Warning already shown in fee info, maybe highlight amount?
                    fromAmountInput.style.borderColor = 'var(--warning-color)';
                 } else if(meetsMinValue && fromAmountInput.style.borderColor === 'var(--warning-color)') {
                     fromAmountInput.style.borderColor = ''; // Reset warning border if value now okay
                 }
                 if(!arePricesAvailable && swapFeeInfoEl.textContent.includes('calculation requires valid prices')) {
                     // Message shown in fee info, do nothing extra here
                 }
             } else {
                 // Reset visual cues if swap is possible or initial state
                  fromAmountInput.style.borderColor = '';
                 swapFromBalanceEl.style.color = '';
             }
        }

         function updateSwapRateAndToAmount() {
             const fromAsset = selectFromTokenBtn.dataset.token;
             const toAsset = selectToTokenBtn.dataset.token;
             const fromAmount = parseFloat(fromAmountInput.value || 0);

             // Reset outputs initially
             toAmountInput.value = ''; // Clear 'To' amount
             swapRateEl.textContent = ''; // Clear rate text
             swapFeeInfoEl.textContent = ''; // Clear fee/min info text

             // Basic validation - need two different, valid tokens with price info
             if (!fromAsset || !toAsset) {
                  swapRateEl.textContent = 'Select From & To tokens'; return;
             }
             if (fromAsset === toAsset) {
                 swapRateEl.textContent = 'Cannot swap the same token'; return;
             }
             if (!tokenData[fromAsset] || !tokenData[toAsset]) {
                 swapRateEl.textContent = 'Token data unavailable'; return;
             }
             const fromPrice = tokenData[fromAsset].priceUSD; // Assumed number by listener validation
             const toPrice = tokenData[toAsset].priceUSD;
              if (fromPrice <= 0 || toPrice <= 0) {
                  swapRateEl.textContent = `Price unavailable for ${fromPrice <= 0 ? fromAsset : toAsset}`;
                  swapFeeInfoEl.textContent = 'Cannot calculate swap or fee.';
                 toAmountInput.value = ''; // Explicitly clear if prices are invalid
                  return;
             }

             // --- Calculate and Display Rate ---
             const baseRate = fromPrice / toPrice;
             swapRateEl.textContent = `1 ${fromAsset} ≈ ${formatTokenAmount(baseRate, 5)} ${toAsset}`;


             // --- Calculate Swap Output & Fee (only if amount is valid) ---
             let feeInfoText = '';
             let calculatedToAmount = 0;

             if (!isNaN(fromAmount) && fromAmount > 0) {
                 const fromUsdValue = fromAmount * fromPrice;
                 const toAmountBeforeFee = fromUsdValue / toPrice;
                 const feeAmount = toAmountBeforeFee * SWAP_FEE_PERCENT;
                 calculatedToAmount = toAmountBeforeFee - feeAmount;

                 // Display the calculated 'to' amount (after fee)
                 // Ensure it doesn't go below zero
                 toAmountInput.value = (calculatedToAmount >= 0) ? formatTokenAmount(calculatedToAmount, 8) : '0';

                 // Prepare fee info text
                  feeInfoText = `Fee: ≈${formatTokenAmount(feeAmount, 6)} ${toAsset} (${(SWAP_FEE_PERCENT * 100).toFixed(2)}%). `;

                 // Check minimum swap value condition based on calculated USD value
                  const fromAmountUsdValue = fromAmount * fromPrice;
                   if (fromAmountUsdValue < MIN_SWAP_USD_VALUE) {
                        feeInfoText += `Min swap value ≈ $${formatCurrency(MIN_SWAP_USD_VALUE)}.`;
                        swapFeeInfoEl.classList.add('warning'); // Add warning class for styling
                   } else {
                         swapFeeInfoEl.classList.remove('warning'); // Remove warning class if condition met
                   }

             } else {
                 // Amount is 0 or invalid, just show base fee percentage
                 feeInfoText = `Fee: ${(SWAP_FEE_PERCENT * 100).toFixed(2)}%.`;
                  toAmountInput.value = ''; // Ensure 'To' amount is clear if 'From' amount is 0
                  swapFeeInfoEl.classList.remove('warning'); // Remove warning if amount is 0
             }

             // Set the final fee/info text
             swapFeeInfoEl.textContent = feeInfoText;
        }


        function updateSendForm() {
            if (!selectSendTokenBtn || !sendAmountInput || !recipientIdInput || !sendAvailableBalanceEl || !sendUsdValueInfoEl || !sendButton || !tokenData || !currentUser) {
                // console.warn("Send form update skipped, elements/data not ready.");
                return;
            }
            // console.log("Updating Send Form UI..."); // Debug log

             const selectedAsset = selectSendTokenBtn.dataset.token || null;
             const availableBalance = parseFloat(userBalance[selectedAsset] || 0);
             const sendAmount = Math.max(0, parseFloat(sendAmountInput.value || 0));
             const recipientId = recipientIdInput.value.trim();

             // Update Available Balance Display
             sendAvailableBalanceEl.textContent = selectedAsset ? `${formatTokenAmount(availableBalance, 8)} ${selectedAsset}` : 'Select Asset';

             // Calculate and Display USD Value & Min Send Check
             let usdValue = 0;
             let priceUsd = 0;
             let usdValueText = ''; // Default to empty
             let isBelowMin = false;
             let isPriceAvailable = false;
              sendUsdValueInfoEl.classList.remove('warning'); // Reset warning style

             if (selectedAsset && tokenData[selectedAsset]) {
                 priceUsd = tokenData[selectedAsset].priceUSD; // Already validated number
                 if (priceUsd > 0) {
                      isPriceAvailable = true;
                      if (sendAmount > 0) {
                          usdValue = sendAmount * priceUsd;
                         usdValueText = `≈ $${formatCurrency(usdValue)} USD`;
                          if (usdValue < MIN_SEND_USD_VALUE) {
                              isBelowMin = true;
                             usdValueText += ` (Min $${formatCurrency(MIN_SEND_USD_VALUE)})`;
                             sendUsdValueInfoEl.classList.add('warning');
                         }
                      } else {
                          usdValueText = `≈ $0.00 USD`; // Show 0 if amount is 0
                      }
                 } else {
                     // Price is 0 or invalid
                      usdValueText = `USD value unavailable`;
                      if (sendAmount > 0) sendUsdValueInfoEl.classList.add('warning'); // Warning only if trying to send
                 }
             } else if (sendAmount > 0 && !selectedAsset) {
                usdValueText = `Select asset first`;
                sendUsdValueInfoEl.classList.add('warning');
            } else {
                usdValueText = '≈ $0.00 USD'; // Default if no asset/amount
             }

             sendUsdValueInfoEl.textContent = usdValueText;


             // --- Validation for Send Button ---
             const isValidRecipient = /^\d+$/.test(recipientId) && recipientId.length > 3;
             const isNotSendingToSelf = recipientId !== String(currentUser.id);
             const hasSufficientBalance = availableBalance >= sendAmount;
             const isValidAmount = sendAmount > 0;
             const meetsMinValue = !isBelowMin || sendAmount === 0; // Allow sending 0

             const canSend = selectedAsset &&
                             isValidAmount &&
                             isValidRecipient &&
                             isNotSendingToSelf &&
                             hasSufficientBalance &&
                             meetsMinValue &&
                             isPriceAvailable; // Ensure price allows check and potential future logic

             sendButton.disabled = !canSend;

             // --- Provide specific visual feedback ---
              recipientIdInput.style.borderColor = ''; // Reset recipient border
              sendAmountInput.style.borderColor = ''; // Reset amount border
              sendAvailableBalanceEl.style.color = ''; // Reset balance color

             if (sendButton.disabled && isValidAmount) { // Only show errors if user has typed an amount
                 if (!isValidRecipient && recipientId.length > 0) { // Invalid format, but user typed *something*
                     recipientIdInput.style.borderColor = 'var(--error-color)';
                 }
                 if (!isNotSendingToSelf) { // Sending to self
                      recipientIdInput.style.borderColor = 'var(--error-color)';
                 }
                 if (!hasSufficientBalance) {
                      sendAmountInput.style.borderColor = 'var(--error-color)';
                      sendAvailableBalanceEl.style.color = 'var(--error-color)';
                 }
                 if (isBelowMin) {
                     sendAmountInput.style.borderColor = 'var(--warning-color)'; // Warning color for below min
                 }
                 if(!isPriceAvailable && selectedAsset){ // Price needed but unavailable
                     // Warning shown in helper text, maybe subtle border?
                      sendAmountInput.style.borderColor = 'var(--warning-color)';
                 }
             }

             // --- Clear specific error messages if conditions resolved ---
             // (Not using explicit message element as much now, relying on button state and input styling)
              if (sendMessage.style.display !== 'none' && sendMessage.classList.contains('error')) {
                 // Optional: Hide global message if the direct cause is fixed
                 if (sendMessage.textContent.includes("Insufficient") && hasSufficientBalance) sendMessage.style.display = 'none';
                 // ... add more conditions if needed
              }
        }


        function updateDepositPageUI() {
            if (currentUser && depositChatIdEl) {
                 depositChatIdEl.textContent = currentUser.id || 'Error: ID Missing';
             } else if (depositChatIdEl) {
                 depositChatIdEl.textContent = 'Loading User Info...';
             }
             if (copyFeedbackDepositEl) {
                 copyFeedbackDepositEl.classList.remove('visible');
                 copyFeedbackDepositEl.textContent = 'Click the ID above to copy'; // Reset text
             }
        }

        function copyTextToClipboard(text, contentType = 'Chat ID') {
             if (!text) { showGlobalMessage(`No ${contentType} to copy.`, 'info'); return; }
             text = String(text); // Ensure it's a string

             if (!navigator.clipboard) {
                 // Fallback for older browsers/non-secure contexts
                 try {
                     const textArea = document.createElement("textarea");
                     textArea.value = text;
                     textArea.style.position = "fixed"; // Avoid scrolling to bottom
                     textArea.style.opacity = "0";
                     document.body.appendChild(textArea);
                     textArea.focus();
                     textArea.select();
                     const successful = document.execCommand('copy');
                     document.body.removeChild(textArea);
                     if (successful) {
                         showFeedback(`${contentType} Copied! (fallback)`);
                     } else {
                         showGlobalMessage(`Fallback copy failed for ${contentType}.`, 'error');
                         triggerHapticFeedback('error');
                     }
                 } catch (err) {
                      console.error(`Fallback Copy Error for ${contentType}: `, err);
                      showGlobalMessage(`Failed to copy ${contentType}.`, 'error');
                      triggerHapticFeedback('error');
                 }
                 return;
            }

            // Modern async clipboard API
            navigator.clipboard.writeText(text).then(() => {
                 showFeedback(`${contentType} Copied!`);
            }).catch(err => {
                console.error(`Failed to copy ${contentType}: `, err);
                 showGlobalMessage(`Failed to copy ${contentType}. Check permissions?`, 'error');
                 triggerHapticFeedback('error');
            });

             function showFeedback(message){
                  if (contentType === 'Chat ID' && copyFeedbackDepositEl) {
                       copyFeedbackDepositEl.textContent = message;
                       copyFeedbackDepositEl.classList.add('visible');
                       setTimeout(() => {
                          copyFeedbackDepositEl.classList.remove('visible');
                          copyFeedbackDepositEl.textContent = 'Click the ID above to copy'; // Reset after timeout
                      }, 2500);
                  } else if (contentType === 'Transaction ID' && typeof showGlobalMessage === 'function'){
                       // Show global message for Tx ID copy
                      showGlobalMessage(message, 'success', 2000);
                  } else {
                     // General feedback as global message
                      showGlobalMessage(message, 'success', 2000);
                  }
                  triggerHapticFeedback('success');
             }
        }


        // --- ACTION HANDLERS (Swap & Send) ---
        async function handleSwap() {
             // Get current state
             const fromAsset = selectFromTokenBtn.dataset.token;
             const toAsset = selectToTokenBtn.dataset.token;
             const fromAmount = parseFloat(fromAmountInput.value);
             const toAmount = parseFloat(toAmountInput.value); // Read calculated 'to' amount

            // --- Re-Validate Before Execution (Crucial!) ---
             if (!currentUser || !fromAsset || !toAsset) {
                 showMessage(swapMessage, "Please select both 'From' and 'To' tokens.", "error"); return;
            }
             if (fromAsset === toAsset) {
                  showMessage(swapMessage, "Cannot swap the same token.", "error"); return;
             }
            if (isNaN(fromAmount) || fromAmount <= 0) {
                showMessage(swapMessage, "Invalid 'From' amount.", "error"); fromAmountInput.focus(); return;
             }
            if (isNaN(toAmount) || toAmount < 0) { // toAmount can theoretically be 0 if fees are high
                showMessage(swapMessage, "Calculated 'To' amount is invalid. Check prices or input.", "error"); return;
             }
             const fromBalance = parseFloat(userBalance[fromAsset] || 0);
             if (fromBalance < fromAmount) {
                 showMessage(swapMessage, `Insufficient ${fromAsset} balance. Required: ${formatTokenAmount(fromAmount)}, Available: ${formatTokenAmount(fromBalance)}`, "error"); return;
             }
             const fromTokenInfo = tokenData[fromAsset];
             const toTokenInfo = tokenData[toAsset];
             if (!fromTokenInfo || !toTokenInfo || fromTokenInfo.priceUSD <= 0 || toTokenInfo.priceUSD <= 0) {
                  showMessage(swapMessage, "Cannot swap due to missing or invalid price information.", "error"); return;
             }
             // Minimum Swap Value Check
             const fromPrice = fromTokenInfo.priceUSD;
              const fromAmountUsdValue = fromAmount * fromPrice;
               if (fromAmountUsdValue < MIN_SWAP_USD_VALUE) {
                    showMessage(swapMessage, `Swap value ($${formatCurrency(fromAmountUsdValue)}) is below the minimum requirement of ≈ $${formatCurrency(MIN_SWAP_USD_VALUE)}.`, "error", 5000); return;
               }
             // --- End Validation ---

             showLoading(true, 'Processing Swap...');
             swapButton.disabled = true;
             triggerHapticFeedback('medium');

             try {
                 // Recalculate final amounts server-side ideally, but re-calc here for tx record accuracy
                 const toPrice = toTokenInfo.priceUSD;
                 const baseRate = fromPrice / toPrice;
                 const fromUsdValueRecalc = fromAmount * fromPrice;
                 const toAmountBeforeFeeRecalc = fromUsdValueRecalc / toPrice;
                 const feeAmountRecalc = toAmountBeforeFeeRecalc * SWAP_FEE_PERCENT;
                 const finalToAmountRecalc = Math.max(0, toAmountBeforeFeeRecalc - feeAmountRecalc); // Ensure non-negative
                 const effectiveRateRecalc = (fromAmount > 0) ? finalToAmountRecalc / fromAmount : 0;

                 // Double-check balance one last time before constructing the update
                 // Note: Real-time db might have changed balance since UI update. Use server-side rules/transactions if high precision needed.
                 // For this client-side approach, we rely on the check above.

                 const balanceUpdates = {
                     [fromAsset]: -fromAmount,
                     [toAsset]: finalToAmountRecalc // Use precise calculated final amount
                 };
                 const txRecord = {
                     type: "swap", fromAsset: fromAsset, fromAmount: fromAmount,
                     toAsset: toAsset, toAmount: finalToAmountRecalc,
                     rate: baseRate, effectiveRate: effectiveRateRecalc,
                     fee: feeAmountRecalc, feeAsset: toAsset, // Fee is denominated in the 'to' asset
                      status: "completed",
                     priceFromUSD: fromPrice, // Log prices used for audit
                     priceToUSD: toPrice
                 };

                 await performSwapTransaction(currentUser.id, balanceUpdates, txRecord);

                 showMessage(swapMessage, `Successfully swapped ${formatTokenAmount(fromAmount)} ${fromAsset} for ~${formatTokenAmount(finalToAmountRecalc)} ${toAsset}!`, "success", 5000);
                 triggerHapticFeedback('success');
                 fromAmountInput.value = ''; // Clear input field
                 // Let the listener trigger the UI update naturally
                 // updateSwapUI(); - Not needed, handled by DB listener reacting to balance change

             } catch (error) {
                 console.error("Swap Transaction Error:", error);
                 showMessage(swapMessage, `Swap failed: ${error.message || "An unknown error occurred. Please try again."}`, "error");
                 triggerHapticFeedback('error');
                 swapButton.disabled = false; // Re-enable button on failure
             } finally {
                 showLoading(false);
                  // UI state (button disable) should be re-evaluated by updateSwapUI called by listener
             }
         }

        async function handleSend() {
             // Get current state
            const asset = selectSendTokenBtn.dataset.token;
            const amountStr = sendAmountInput.value;
            const recipientId = recipientIdInput.value.trim();
            const amount = parseFloat(amountStr); // Use parsed amount for calculations

            // --- Re-Validate Before Execution ---
             if (!currentUser || !asset) {
                 showMessage(sendMessage, "Please select an asset to send.", "error"); return;
             }
             if (!amountStr || isNaN(amount) || amount <= 0) {
                  showMessage(sendMessage, "Please enter a valid positive amount to send.", "error"); sendAmountInput.focus(); return;
             }
             if (!recipientId || !/^\d+$/.test(recipientId) || recipientId.length <= 3) {
                  showMessage(sendMessage, "Invalid Recipient Telegram Chat ID. Enter numbers only.", "error"); recipientIdInput.focus(); return;
             }
             const senderId = String(currentUser.id);
              if (recipientId === senderId) {
                 showMessage(sendMessage, "You cannot send assets to your own Chat ID.", "error"); recipientIdInput.focus(); return;
             }
             const balance = parseFloat(userBalance[asset] || 0);
             if (balance < amount) {
                  showMessage(sendMessage, `Insufficient ${asset} balance. Needed: ${formatTokenAmount(amount)}, Available: ${formatTokenAmount(balance)}.`, "error"); return;
             }
             const tokenInfo = tokenData[asset];
             if (!tokenInfo || tokenInfo.priceUSD <= 0) {
                 showMessage(sendMessage, `Cannot send ${asset} due to missing or invalid price information. Transaction blocked.`, "error"); return;
             }
             // Minimum Send Value Check
             const priceUsd = tokenInfo.priceUSD;
             const usdValue = amount * priceUsd;
             if (usdValue < MIN_SEND_USD_VALUE) {
                 showMessage(sendMessage, `Send value ($${formatCurrency(usdValue)}) is below the minimum requirement of $${formatCurrency(MIN_SEND_USD_VALUE)}.`, "error", 6000); return;
             }
             // --- End Validation ---

             showLoading(true, 'Processing Transfer...');
             sendButton.disabled = true;
             triggerHapticFeedback('medium'); // Use medium for potentially significant action

             try {
                 await performP2PTransfer(senderId, recipientId, asset, amount);
                 showMessage(sendMessage, `Successfully sent ${formatTokenAmount(amount)} ${asset} to user ${recipientId}.`, "success", 5000);
                 triggerHapticFeedback('success');

                 // Clear form AFTER successful send
                 sendAmountInput.value = '';
                 recipientIdInput.value = '';
                 // Reset selected token button appearance explicitly
                 const sendButtonInfo = selectSendTokenBtn.querySelector('.selected-token-info');
                 sendButtonInfo.innerHTML = `<span class="select-prompt">Select Asset to Send</span>`;
                 selectSendTokenBtn.dataset.token = ''; // Clear selected token data

                 // Manually trigger updateSendForm to reflect cleared state immediately
                 updateSendForm();
                 // The listener will eventually update balances, reinforcing this.

             } catch (error) {
                 console.error("Send Transaction Error:", error);
                 triggerHapticFeedback('error');
                 if (error.code === "RECIPIENT_NOT_FOUND") {
                     showMessage(sendMessage, error.message, "error", 6000); // Show specific not found error
                     recipientIdInput.style.borderColor = 'var(--error-color)'; // Highlight recipient field
                     recipientIdInput.focus();
                 } else if (error.message && error.message.includes("permission_denied")) {
                     showMessage(sendMessage, `Transfer failed due to a database permission issue. Please try again later or contact support.`, "error", 7000);
                 } else {
                     // General failure message
                     showMessage(sendMessage, `Send failed: ${error.message || "An unexpected error occurred."}. Please check details and try again.`, "error", 7000);
                 }
                  sendButton.disabled = false; // Re-enable button on failure
             } finally {
                 showLoading(false);
                 // Button state will be updated by updateSendForm (called manually or by listener)
             }
         }

        // --- EVENT LISTENERS SETUP ---
        function setupEventListeners() {
             if (listenersAttached) { console.warn("Skipping: Event listeners already attached."); return; }
             console.log("Setting up event listeners...");

             // Navigation
             navItems.forEach(item => { item.addEventListener('click', () => { showPage(item.dataset.page); triggerHapticFeedback('light'); }); });

             // Swap Page Listeners
             if (selectFromTokenBtn) selectFromTokenBtn.addEventListener('click', () => openTokenSelector('swap-from')); else console.warn("#selectFromTokenBtn not found");
             if (selectToTokenBtn) selectToTokenBtn.addEventListener('click', () => openTokenSelector('swap-to')); else console.warn("#selectToTokenBtn not found");
             if (fromAmountInput) fromAmountInput.addEventListener('input', updateSwapUI); else console.warn("#fromAmount not found");
             if (swapButton) swapButton.addEventListener('click', handleSwap); else console.warn("#swapButton not found");
             if (swapDirectionBtn) swapDirectionBtn.addEventListener('click', () => {
                 console.log("Swap direction clicked");
                 const fromAsset = selectFromTokenBtn.dataset.token;
                 const toAsset = selectToTokenBtn.dataset.token;

                 if (!fromAsset || !toAsset) return; // Need both tokens selected
                  // No need to prevent swapping same token here, UI should prevent selection

                  console.log(`Swapping direction: ${fromAsset} <-> ${toAsset}`);

                  // Swap data attributes
                 selectFromTokenBtn.dataset.token = toAsset;
                 selectToTokenBtn.dataset.token = fromAsset;

                  // Swap display on buttons requires getting current content
                 const fromBtnSpan = selectFromTokenBtn.querySelector('.selected-token-info');
                 const toBtnSpan = selectToTokenBtn.querySelector('.selected-token-info');
                 const fromBtnContent = fromBtnSpan.innerHTML; // Store current HTML
                 const toBtnContent = toBtnSpan.innerHTML;

                  if (!fromBtnContent.includes('select-prompt') && !toBtnContent.includes('select-prompt')) {
                      // Only swap content if both buttons actually have a token selected
                      fromBtnSpan.innerHTML = toBtnContent;
                      toBtnSpan.innerHTML = fromBtnContent;
                  } else if (fromBtnContent.includes('select-prompt') && !toBtnContent.includes('select-prompt')){
                      // Move selected token from 'To' to 'From', reset 'To'
                      fromBtnSpan.innerHTML = toBtnContent;
                      toBtnSpan.innerHTML = '<span class="select-prompt">Select Token</span>';
                  } else if (!fromBtnContent.includes('select-prompt') && toBtnContent.includes('select-prompt')){
                      // Move selected token from 'From' to 'To', reset 'From'
                      toBtnSpan.innerHTML = fromBtnContent;
                       fromBtnSpan.innerHTML = '<span class="select-prompt">Select Token</span>';
                   } // else: both are prompts, do nothing visually except update data attribute

                 triggerHapticFeedback('medium');
                 updateSwapUI(); // Update UI immediately after swapping direction
             }); else console.warn("#swapDirectionBtn not found");

             // Receive Page Listener
             if (depositChatIdEl) depositChatIdEl.addEventListener('click', () => { if(currentUser && currentUser.id) copyTextToClipboard(String(currentUser.id), 'Chat ID'); else showGlobalMessage('User ID not available to copy.', 'info'); }); else console.warn("#depositChatId not found");

             // Send Page Listeners
             if (selectSendTokenBtn) selectSendTokenBtn.addEventListener('click', () => openTokenSelector('send')); else console.warn("#selectSendTokenBtn not found");
             if (sendAmountInput) sendAmountInput.addEventListener('input', updateSendForm); else console.warn("#sendAmount not found");
             if (recipientIdInput) recipientIdInput.addEventListener('input', updateSendForm); else console.warn("#recipientId not found");
             if (sendButton) sendButton.addEventListener('click', handleSend); else console.warn("#sendButton not found");

            // Token Modal Listeners
            if (modalCloseBtn) modalCloseBtn.addEventListener('click', closeTokenSelector); else console.warn("#modalCloseBtn not found");
            if (tokenSelectorOverlay) tokenSelectorOverlay.addEventListener('click', (event) => { if (event.target === tokenSelectorOverlay) closeTokenSelector(); }); else console.warn("#tokenSelectorOverlay not found");
            if (modalSearchInput) modalSearchInput.addEventListener('input', populateTokenList); else console.warn("#modalSearchInput not found");

             // Global listener for theme changes
             if (tg && tg.onEvent) {
                try {
                    tg.onEvent('themeChanged', () => applyTheme(tg.themeParams));
                     console.log("Theme change listener attached.");
                } catch (e) {
                    console.error("Error attaching theme change listener:", e);
                }
             } else {
                 console.warn("tg.onEvent not available for theme change listener.");
             }


             // Transaction ID Copy Listener (delegated from parent)
             // Check if element exists before attaching listener
             if (transactionListEl) {
                  transactionListEl.addEventListener('click', function(event) {
                      // Find the closest ancestor span with the class 'tx-id'
                     const txIdSpan = event.target.closest('span.tx-id');
                     if (txIdSpan) {
                         // Extract the full ID from the title attribute
                         const fullTxId = txIdSpan.getAttribute('title')?.replace('Click to copy Tx ID: ', '');
                          if (fullTxId) {
                             copyTextToClipboard(fullTxId, 'Transaction ID');
                         } else {
                             console.warn("Could not extract full Tx ID from title attribute:", txIdSpan);
                         }
                     }
                 });
                 console.log("Transaction list copy listener attached.");
             } else {
                console.warn("#transactionList element not found for delegation.");
             }


             listenersAttached = true;
             console.log("Event listeners setup complete.");
         }

        // --- INITIALIZATION ---
        async function initializeApp() {
            console.log("--- Initializing AB Wallet App ---");
            showLoading(true, 'Connecting...');
            let initSuccess = true; // Track success

             // 0. Replace Placeholder Config
             if (firebaseConfig.apiKey === "YOUR_API_KEY") {
                 console.error("CRITICAL: Firebase config not replaced!");
                  showGlobalMessage("App configuration error. Please contact support.", "error", 0);
                  if (appBlocker) {
                     appBlocker.querySelector('h2').textContent = 'Configuration Error';
                     appBlocker.querySelector('p').textContent = 'The application is not configured correctly. Please contact the developer.';
                     appBlocker.style.display = 'flex';
                 }
                  showLoading(false);
                  return; // Stop initialization
              }


             // 1. Check Telegram Environment
             if (typeof window.Telegram === 'undefined' || !window.Telegram.WebApp) {
                 console.error("Fatal Error: Telegram WebApp SDK not found.");
                 showLoading(false);
                  initSuccess = false;
                  if (appBlocker) {
                     // Make sure blocker exists before accessing children
                     const h2 = appBlocker.querySelector('h2');
                     const p = appBlocker.querySelector('p');
                     if (h2) h2.textContent = 'Environment Error';
                     if (p) p.textContent = 'This application can only be used inside the Telegram app.';
                     appBlocker.style.display = 'flex';
                  }
                 return; // Stop initialization
             }
             tg = window.Telegram.WebApp;

             // Setup listener for viewport changes immediately
            //  if(tg && tg.onEvent) {
            //       tg.onEvent('viewportChanged', (event) => {
            //            console.log('Viewport changed:', event);
            //             // Add logic here if needed based on viewport stable/unstable
            //      });
            // }


             try {
                 // 2. Telegram Ready & Setup
                 console.log("Waiting for Telegram SDK ready...");
                 await new Promise(resolve => tg.ready(resolve)); // Ensure tg.ready() completes
                 console.log("Telegram WebApp SDK Ready");
                 tg.expand();
                  applyTheme(tg.themeParams); // Apply initial theme
                  if (tg.MainButton) tg.MainButton.hide(); // Ensure main button is hidden

                 // 3. Get User Data from Telegram
                  if (tg.initDataUnsafe && tg.initDataUnsafe.user && tg.initDataUnsafe.user.id) {
                     currentUser = tg.initDataUnsafe.user;
                     console.log("User Identified:", currentUser.id, currentUser.username ? `@${currentUser.username}` : '(No username)');
                      updateHomePageUI(); // Show basic user info immediately
                     updateDepositPageUI();
                  } else {
                      throw new Error("Could not retrieve valid Telegram user data.");
                  }

                  // 4. Initialize Firebase
                 showLoading(true, 'Connecting to Wallet...');
                 await initializeFirebase();
                  if (!db) throw new Error("Database connection failed during initialization.");


                  // 5. Setup Real-time Listener for Token Data *** INTEGRATED STEP ***
                  showLoading(true, 'Loading Token Info...');
                  await listenForTokenData(); // Waits for FIRST load, sets up ongoing listener


                  // 6. Setup Real-time Listener for User's Wallet Data
                  showLoading(true, 'Loading Your Balances...');
                  // Start listener, wait for initial data OR user creation
                  await getUserDataRealtime(String(currentUser.id));


                  // 7. Setup Event Listeners (Now safe as core data structures exist)
                  setupEventListeners();

                 // 8. Initialization Complete
                 showLoading(false);
                 showPage('homePage'); // Show home page first
                 console.log("--- App Initialization Complete ---");

             } catch (error) {
                  console.error("--- App Initialization Failed ---", error);
                  showLoading(false);
                  initSuccess = false;
                 triggerHapticFeedback('error');
                  let userMessage = `Initialization Error: ${error.message || 'An unknown error occurred.'}. Please try restarting the app.`;
                  let blockerTitle = 'Initialization Error';

                  if (error.message.includes("Telegram user data")) {
                     blockerTitle = 'User Data Error';
                     userMessage = error.message + " Ensure you are running this inside Telegram.";
                  } else if (error.message.includes("Firebase")) {
                     userMessage = `Database Connection Error: ${error.message}. Check network connection or contact support.`;
                      blockerTitle = 'Connection Error';
                  } else if (error.message.includes("Database connection failed")){
                       userMessage = `Failed to connect to the wallet database. Please check your internet connection and try again.`;
                      blockerTitle = 'Connection Error';
                  }

                  showGlobalMessage(userMessage, "error", 0); // Show persistent global message

                 // Optionally use the blocker for critical failures
                 if (error.message.includes("Telegram user data") || error.message.includes("Database connection failed")) {
                      if (appBlocker) {
                         const h2 = appBlocker.querySelector('h2');
                         const p = appBlocker.querySelector('p');
                         if (h2) h2.textContent = blockerTitle;
                         if (p) p.textContent = userMessage;
                          appBlocker.style.display = 'flex';
                     }
                 }
            } finally {
                 if (!initSuccess) {
                    console.log("Initialization ended with errors.");
                     // Maybe disable core features if init failed badly?
                 }
            }
         }

        // --- Start the app ---
         document.addEventListener('DOMContentLoaded', initializeApp);

     </script>

</body>
</html>
