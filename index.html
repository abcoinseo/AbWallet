<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AB Wallet</title>
    <!-- Telegram WebApp SDK -->
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>

    <style>
        :root {
            --bg-color: #121212;
            --primary-text: #ffffff;
            --secondary-text: #b3b3b3;
            --card-bg: #282828;
            --accent-color: #1DB954; /* Example: Spotify Green */
            --button-bg: #1DB954;
            --button-text: #ffffff;
            --input-bg: #333333;
            --border-color: #444444;
            --error-color: #f44336;
            --success-color: #4caf50;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--primary-text);
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            padding-bottom: 60px; /* Space for bottom nav */
        }

        .app-container {
            flex-grow: 1;
            padding: 15px;
            overflow-y: auto;
        }

        /* --- Page Sections --- */
        .page {
            display: none; /* Hidden by default */
            animation: fadeIn 0.3s ease-in-out;
        }
        .page.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* --- Navigation --- */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background-color: var(--card-bg);
            display: flex;
            justify-content: space-around;
            align-items: center;
            border-top: 1px solid var(--border-color);
            z-index: 1000;
        }

        .nav-item {
            background: none;
            border: none;
            color: var(--secondary-text);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 12px;
            padding: 5px;
            transition: color 0.2s ease;
        }
        .nav-item svg { /* Basic icon styling */
            width: 24px;
            height: 24px;
            margin-bottom: 4px;
            fill: currentColor;
        }
        .nav-item.active {
            color: var(--accent-color);
        }
        .nav-item:hover {
            color: var(--primary-text);
        }


        /* --- Common Elements --- */
        h1, h2, h3 {
            color: var(--primary-text);
            margin-bottom: 15px;
        }
        h1 { font-size: 24px; }
        h2 { font-size: 20px; }
        h3 { font-size: 16px; color: var(--secondary-text); margin-bottom: 10px;}

        .card {
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .balance-display {
            font-size: 28px;
            font-weight: bold;
            color: var(--primary-text);
            text-align: center;
            margin-bottom: 20px;
        }
        .balance-display span {
            font-size: 16px;
            font-weight: normal;
            color: var(--secondary-text);
        }

        .user-info p {
            margin-bottom: 5px;
            color: var(--secondary-text);
        }
        .user-info strong {
            color: var(--primary-text);
        }


        label {
            display: block;
            margin-bottom: 5px;
            color: var(--secondary-text);
            font-size: 14px;
        }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            color: var(--primary-text);
            font-size: 16px;
        }
        input:focus, select:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        button {
            background-color: var(--button-bg);
            color: var(--button-text);
            border: none;
            padding: 15px;
            border-radius: 25px; /* Pill shape */
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            width: 100%;
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin-top: 10px;
        }
        button:hover {
            background-color: #1aa34a; /* Slightly darker green */
        }
        button:active {
            transform: scale(0.98);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }


        .token-select-item {
            display: flex;
            align-items: center;
        }
         .token-select-item img {
             width: 24px;
             height: 24px;
             margin-right: 10px;
             border-radius: 50%;
             background-color: #fff; /* Placeholder bg */
         }

        .swap-icon {
            text-align: center;
            margin: 15px 0;
            font-size: 24px;
            cursor: pointer;
            color: var(--accent-color);
        }

        .message {
            padding: 10px;
            margin: 15px 0;
            border-radius: 5px;
            text-align: center;
            font-size: 14px;
        }
        .message.error {
            background-color: rgba(244, 67, 54, 0.2);
            color: var(--error-color);
            border: 1px solid var(--error-color);
        }
        .message.success {
             background-color: rgba(76, 175, 80, 0.2);
             color: var(--success-color);
             border: 1px solid var(--success-color);
         }

        .loading-indicator {
             text-align: center;
             padding: 20px;
             color: var(--secondary-text);
             display: none; /* Hidden initially */
         }
         .loading-indicator.active {
             display: block;
         }

        .chat-id-display {
            background-color: var(--input-bg);
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            word-break: break-all;
            margin-top: 5px;
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            text-align: center;
        }
         .copy-feedback {
             font-size: 12px;
             color: var(--success-color);
             text-align: center;
             height: 15px; /* Reserve space */
             margin-top: -10px;
             margin-bottom: 10px;
         }

        .transaction-history ul {
            list-style: none;
            padding: 0;
            max-height: 200px;
            overflow-y: auto;
        }
        .transaction-history li {
            background-color: var(--input-bg);
            padding: 10px;
            margin-bottom: 5px;
            border-radius: 4px;
            font-size: 13px;
            color: var(--secondary-text);
            border-left: 3px solid var(--accent-color);
        }
         .transaction-history li.deposit { border-left-color: var(--success-color); }
         .transaction-history li.withdraw { border-left-color: var(--error-color); }
         .transaction-history li.swap { border-left-color: orange; }

        .transaction-history li span { color: var(--primary-text); font-weight: 500;}


    </style>
</head>
<body>

    <div class="app-container">

        <!-- Loading Indicator -->
        <div id="loadingIndicator" class="loading-indicator">Loading...</div>

        <!-- Global Message Area -->
        <div id="globalMessage" class="message" style="display: none;"></div>

        <!-- Home Page -->
        <div id="homePage" class="page active">
            <h1>Welcome, <span id="userName">User</span>!</h1>

            <div class="card">
                <h2>Total Balance</h2>
                <div class="balance-display" id="totalBalance">
                    $0.00 <span>USD</span>
                </div>
                <!-- Detailed Balances (Optional) -->
                 <div id="detailedBalances">
                     <h3>Asset Balances:</h3>
                     <ul id="assetList">
                         <!-- Asset balances will be listed here -->
                     </ul>
                 </div>
            </div>

            <div class="card user-info">
                <h2>User Information</h2>
                <p><strong>First Name:</strong> <span id="userFirstName"></span></p>
                <p><strong>Last Name:</strong> <span id="userLastName"></span></p>
                <p><strong>Username:</strong> <span id="userUsername"></span></p>
                <p><strong>Chat ID:</strong> <span id="userChatId"></span></p>
            </div>

             <div class="card transaction-history">
                 <h2>Recent Activity</h2>
                 <ul id="transactionList">
                    <!-- Transactions will be listed here -->
                    <li>No transactions yet.</li>
                 </ul>
            </div>
        </div>

        <!-- Swap Page -->
        <div id="swapPage" class="page">
            <h1>Swap Assets</h1>
            <div class="card">
                <div id="swapMessage" class="message" style="display: none;"></div>

                <label for="fromToken">From:</label>
                <select id="fromToken"></select>
                <input type="number" id="fromAmount" placeholder="Amount to swap" min="0" step="any">

                <div class="swap-icon" id="swapDirectionBtn">⇅</div>

                <label for="toToken">To:</label>
                <select id="toToken"></select>
                <input type="number" id="toAmount" placeholder="Estimated amount" readonly>

                <p id="swapRate" style="text-align: center; margin-bottom: 15px; color: var(--secondary-text); font-size: 14px;">Select tokens to see rate</p>

                <button id="swapButton" disabled>Swap</button>
            </div>
        </div>

        <!-- Deposit Page -->
        <div id="depositPage" class="page">
            <h1>Deposit Assets</h1>
            <div class="card">
                 <div id="depositMessage" class="message" style="display: none;"></div>
                <p style="color: var(--secondary-text); margin-bottom: 15px;">To deposit assets, you would typically send them to a specific wallet address. Since this is a simulation within Telegram, we'll use your unique Chat ID for identification.</p>

                <h3>Your Unique Deposit Identifier (Chat ID):</h3>
                <div id="depositChatId" class="chat-id-display" title="Click to copy">Loading...</div>
                <div id="copyFeedbackDeposit" class="copy-feedback"></div>

                <p style="color: var(--secondary-text;); font-size: 14px; margin-top: 15px;">
                    **Simulation Only:** In a real scenario, you'd see deposit addresses for different cryptocurrencies here. For this demo, any simulated "deposit" action will be linked to your Chat ID in the database. You could simulate receiving USDT by contacting support or via a simulated faucet (not implemented here).
                 </p>

                 <!-- Example Simulation Button (Optional) -->
                 <!--
                 <label for="depositAmountSim">Simulate USDT Deposit Amount:</label>
                 <input type="number" id="depositAmountSim" placeholder="e.g., 100" min="1">
                 <button id="simulateDepositBtn">Simulate Receiving USDT</button>
                 -->
            </div>
        </div>

        <!-- Withdraw Page -->
        <div id="withdrawPage" class="page">
            <h1>Withdraw Assets</h1>
            <div class="card">
                 <div id="withdrawMessage" class="message" style="display: none;"></div>
                <label for="withdrawToken">Asset to Withdraw:</label>
                <select id="withdrawToken">
                    <!-- Options populated by JS -->
                </select>

                <label for="withdrawAmount">Amount:</label>
                <input type="number" id="withdrawAmount" placeholder="Amount" min="0" step="any">
                <p style="font-size: 12px; color: var(--secondary-text); margin-top: -10px; margin-bottom: 10px;">Available: <span id="withdrawAvailableBalance">0.00</span></p>

                <label for="recipientInfo">Recipient Info (e.g., Chat ID for simulation):</label>
                <input type="text" id="recipientInfo" placeholder="Enter Recipient Chat ID (for simulation)">

                <p style="color: var(--secondary-text;); font-size: 14px; margin-bottom: 15px;">
                    **Simulation Only:** In a real wallet, you would enter a valid crypto address. Here, we simulate sending based on the provided info (like another user's Chat ID). No actual crypto is moved.
                </p>

                <button id="withdrawButton" disabled>Withdraw</button>
            </div>
        </div>

    </div>

    <!-- Bottom Navigation -->
    <nav class="bottom-nav">
        <button class="nav-item active" data-page="homePage">
            <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8h5z"/></svg>
            Home
        </button>
        <button class="nav-item" data-page="swapPage">
             <svg viewBox="0 0 24 24"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"/></svg>
            Swap
        </button>
        <button class="nav-item" data-page="depositPage">
             <svg viewBox="0 0 24 24"><path d="M5 4v2h14V4H5zm0 10h4v6h6v-6h4l-7-7-7 7z"/></svg>
            Deposit
        </button>
        <button class="nav-item" data-page="withdrawPage">
             <svg viewBox="0 0 24 24"><path d="M9 16h6v-6h4l-7-7-7 7h4v6zm-4 2h14v2H5v-2z"/></svg>
            Withdraw
        </button>
    </nav>

    <script>
        const firebaseConfig = {
            apiKey: "AIzaSyBW1WPXUN8DYhT6npZQYoQ3l4J-jFSbzfg", // Replace with your actual key if needed, but insecure!
            authDomain: "ab-studio-marketcap.firebaseapp.com",
            databaseURL: "https://ab-studio-marketcap-default-rtdb.firebaseio.com",
            projectId: "ab-studio-marketcap",
            storageBucket: "ab-studio-marketcap.firebasestorage.app",
            messagingSenderId: "115268088088",
            appId: "1:115268088088:web:65643a047f92bfaa66ee6d"
        };

        // --- GLOBAL STATE ---
        let currentUser = null;
        let userDbRef = null;
        let db = null;
        let userBalance = {}; // { USDT: 100, ABT: 5000 }
        let tokenData = {}; // { USDT: { name: ..., priceUSD: ... }, ABT: { ... } }
        let tg = window.Telegram.WebApp;

        // --- DOM Elements ---
        const loadingIndicator = document.getElementById('loadingIndicator');
        const globalMessage = document.getElementById('globalMessage');
        const pages = document.querySelectorAll('.page');
        const navItems = document.querySelectorAll('.nav-item');

        // Home Page Elements
        const userNameEl = document.getElementById('userName');
        const totalBalanceEl = document.getElementById('totalBalance');
        const userFirstNameEl = document.getElementById('userFirstName');
        const userLastNameEl = document.getElementById('userLastName');
        const userUsernameEl = document.getElementById('userUsername');
        const userChatIdEl = document.getElementById('userChatId');
        const assetListEl = document.getElementById('assetList');
        const transactionListEl = document.getElementById('transactionList');

        // Swap Page Elements
        const fromTokenSelect = document.getElementById('fromToken');
        const toTokenSelect = document.getElementById('toToken');
        const fromAmountInput = document.getElementById('fromAmount');
        const toAmountInput = document.getElementById('toAmount');
        const swapButton = document.getElementById('swapButton');
        const swapMessage = document.getElementById('swapMessage');
        const swapRateEl = document.getElementById('swapRate');
        const swapDirectionBtn = document.getElementById('swapDirectionBtn');

        // Deposit Page Elements
        const depositChatIdEl = document.getElementById('depositChatId');
        const depositMessage = document.getElementById('depositMessage');
        const copyFeedbackDepositEl = document.getElementById('copyFeedbackDeposit');
        // const simulateDepositBtn = document.getElementById('simulateDepositBtn'); // Uncomment if using simulation button
        // const depositAmountSimInput = document.getElementById('depositAmountSim'); // Uncomment if using simulation button

        // Withdraw Page Elements
        const withdrawTokenSelect = document.getElementById('withdrawToken');
        const withdrawAmountInput = document.getElementById('withdrawAmount');
        const recipientInfoInput = document.getElementById('recipientInfo');
        const withdrawButton = document.getElementById('withdrawButton');
        const withdrawMessage = document.getElementById('withdrawMessage');
        const withdrawAvailableBalanceEl = document.getElementById('withdrawAvailableBalance');


        // --- UTILITY FUNCTIONS ---
        function showLoading(show) {
            loadingIndicator.style.display = show ? 'block' : 'none';
        }

        function showMessage(element, message, type = 'error') {
            element.textContent = message;
            element.className = `message ${type}`;
            element.style.display = 'block';
            setTimeout(() => {
                element.style.display = 'none';
            }, 5000); // Hide after 5 seconds
        }

        function showGlobalMessage(message, type = 'error') {
            showMessage(globalMessage, message, type);
        }

        function formatCurrency(amount, decimals = 2) {
            return parseFloat(amount).toFixed(decimals);
        }

        function formatTokenAmount(amount, decimals = 6) {
            // Adjust decimals based on token if needed
            const num = parseFloat(amount);
            if (isNaN(num)) return '0';
            return num.toLocaleString(undefined, { maximumFractionDigits: decimals });
         }

        // --- PAGE NAVIGATION ---
        function showPage(pageId) {
            pages.forEach(page => {
                page.classList.toggle('active', page.id === pageId);
            });
            navItems.forEach(item => {
                item.classList.toggle('active', item.dataset.page === pageId);
            });
            window.scrollTo(0, 0); // Scroll to top on page change
             // Reset messages on page change
             globalMessage.style.display = 'none';
             swapMessage.style.display = 'none';
             depositMessage.style.display = 'none';
             withdrawMessage.style.display = 'none';
             // Refresh data if needed when switching to certain pages
             if (pageId === 'homePage') {
                 updateHomePageUI();
             } else if (pageId === 'swapPage') {
                 populateTokenSelectors(); // Ensure tokens are loaded
                 updateSwapUI();
             } else if (pageId === 'withdrawPage') {
                 populateWithdrawTokenSelector();
                 updateWithdrawForm();
             }
        }

        // --- FIREBASE FUNCTIONS ---
        function initializeFirebase() {
            try {
                firebase.initializeApp(firebaseConfig);
                db = firebase.database();
                console.log("Firebase Initialized");
                return true;
            } catch (error) {
                console.error("Firebase Initialization Error:", error);
                showGlobalMessage("Error connecting to database. Please try again later.", "error");
                showLoading(false);
                return false;
            }
        }

        function getUserData(userId) {
             if (!db || !userId) return Promise.reject("Database or UserID not available");
             userDbRef = db.ref(`users/${userId}`);

             return new Promise((resolve, reject) => {
                 userDbRef.on('value', (snapshot) => {
                     const data = snapshot.val();
                     if (data) {
                         userBalance = data.balances || {}; // Initialize if no balances yet
                         updateHomePageUI(); // Update UI whenever data changes
                         updateSwapUI(); // Update swap page balances
                         updateWithdrawForm(); // Update withdraw form balances
                         populateWithdrawTokenSelector(); // Repopulate withdraw tokens based on balance
                         updateTransactionHistory(data.transactions || {});
                         resolve(data);
                     } else {
                         // User doesn't exist yet, create basic structure
                         console.log("User not found in DB, creating entry...");
                         const initialUserData = {
                             chatId: currentUser.id,
                             firstName: currentUser.first_name || '',
                             lastName: currentUser.last_name || '',
                             username: currentUser.username || 'N/A',
                             balances: { USDT: 0 }, // Start with 0 USDT balance
                             transactions: {}
                         };
                         userDbRef.set(initialUserData)
                            .then(() => {
                                userBalance = initialUserData.balances;
                                updateHomePageUI();
                                updateWithdrawForm();
                                updateTransactionHistory({});
                                resolve(initialUserData);
                             })
                            .catch(reject);
                     }
                 }, (error) => {
                     console.error("Firebase Read Error:", error);
                     showGlobalMessage("Failed to load user data.", "error");
                     reject(error);
                 });
             });
        }

         function getTokenData() {
             if (!db) return Promise.reject("Database not available");
             const tokensRef = db.ref('tokens');
             return tokensRef.once('value')
                 .then(snapshot => {
                     tokenData = snapshot.val() || {};
                     console.log("Token data loaded:", tokenData);
                     populateTokenSelectors(); // Populate swap dropdowns now
                     updateHomePageUI(); // Recalculate total balance with token prices
                     return tokenData;
                 })
                 .catch(error => {
                     console.error("Error fetching token data:", error);
                     showGlobalMessage("Failed to load token information.", "error");
                     return {}; // Return empty object on error
                 });
         }

        async function updateBalance(userId, asset, amountChange) {
            if (!db || !userId) return Promise.reject("Database or UserID not available");
            const balanceRef = db.ref(`users/${userId}/balances/${asset}`);

            return db.runTransaction(balanceRef, (currentBalance) => {
                 const currentVal = parseFloat(currentBalance || 0);
                 const newVal = currentVal + parseFloat(amountChange);
                 if (newVal < 0) {
                     // Insufficient funds - transaction will abort
                     console.warn(`Transaction aborted: Insufficient ${asset} balance.`);
                     return; // Abort transaction by returning undefined
                 }
                 return newVal;
             });
         }

        async function recordTransaction(userId, txData) {
            if (!db || !userId) return Promise.reject("Database or UserID not available");
             const txRef = db.ref(`users/${userId}/transactions`).push();
             const timestamp = new Date().toISOString();
             return txRef.set({
                 ...txData,
                 timestamp: timestamp,
                 status: txData.status || "completed" // Default to completed
             });
         }

        // --- UI UPDATE FUNCTIONS ---
        function updateHomePageUI() {
             if (!currentUser) return;

             userNameEl.textContent = currentUser.first_name || 'User';
             userFirstNameEl.textContent = currentUser.first_name || 'N/A';
             userLastNameEl.textContent = currentUser.last_name || 'N/A';
             userUsernameEl.textContent = currentUser.username ? `@${currentUser.username}` : 'N/A';
             userChatIdEl.textContent = currentUser.id || 'N/A';
             depositChatIdEl.textContent = currentUser.id || 'N/A'; // Also update deposit page

             // Calculate total balance in USD
             let totalUsdValue = 0;
             assetListEl.innerHTML = ''; // Clear previous list
             if (Object.keys(userBalance).length === 0) {
                assetListEl.innerHTML = '<li>No assets yet.</li>';
             } else {
                 for (const asset in userBalance) {
                     const balance = parseFloat(userBalance[asset] || 0);
                     const tokenInfo = tokenData[asset];
                     const priceUsd = tokenInfo ? parseFloat(tokenInfo.priceUSD || 0) : 0;
                     const usdValue = balance * priceUsd;
                     totalUsdValue += usdValue;

                     // Add to asset list
                     const li = document.createElement('li');
                     li.style.display = 'flex';
                     li.style.justifyContent = 'space-between';
                     li.style.padding = '5px 0';
                     li.style.borderBottom = `1px solid ${getComputedStyle(document.documentElement).getPropertyValue('--border-color')}`;
                     li.innerHTML = `
                        <span>
                            <img src="${tokenInfo?.logoUrl || 'https://via.placeholder.com/24'}" alt="${asset}" style="width: 20px; height: 20px; vertical-align: middle; margin-right: 5px; border-radius: 50%;">
                            ${formatTokenAmount(balance)} <strong>${asset}</strong>
                        </span>
                        <span style="color: var(--secondary-text); font-size: 12px;">≈ $${formatCurrency(usdValue)}</span>
                    `;
                     assetListEl.appendChild(li);
                 }
             }

             totalBalanceEl.innerHTML = `$${formatCurrency(totalUsdValue)} <span>USD</span>`;
         }

         function updateTransactionHistory(transactions) {
            transactionListEl.innerHTML = ''; // Clear previous list
            const txArray = Object.entries(transactions || {}).map(([key, value]) => ({ id: key, ...value }));
            txArray.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // Sort newest first

            if (txArray.length === 0) {
                 transactionListEl.innerHTML = '<li>No transactions yet.</li>';
                 return;
            }

             txArray.slice(0, 10).forEach(tx => { // Show latest 10 transactions
                 const li = document.createElement('li');
                 li.classList.add(tx.type); // Add class for styling (deposit, withdraw, swap)
                 let description = '';
                 switch (tx.type) {
                     case 'deposit':
                         description = `Deposited <span>${formatTokenAmount(tx.amount)} ${tx.asset}</span>`;
                         break;
                     case 'withdraw':
                         description = `Withdrew <span>${formatTokenAmount(tx.amount)} ${tx.asset}</span> to ${tx.to || 'recipient'}`;
                         break;
                     case 'swap':
                         description = `Swapped <span>${formatTokenAmount(tx.fromAmount)} ${tx.fromAsset}</span> for <span>${formatTokenAmount(tx.toAmount)} ${tx.toAsset}</span>`;
                         break;
                     default:
                         description = `Unknown transaction type`;
                 }
                 li.innerHTML = `${description} <small style="float: right; color: var(--secondary-text)">${new Date(tx.timestamp).toLocaleString()}</small>`;
                 transactionListEl.appendChild(li);
             });
        }

        function populateTokenSelectors() {
             if (!tokenData || Object.keys(tokenData).length === 0) {
                 console.warn("Token data not available for populating selectors.");
                 // Maybe show a message in the swap UI
                 return;
             }

             // Clear existing options
             fromTokenSelect.innerHTML = '';
             toTokenSelect.innerHTML = '';

             let firstOption = true;
             for (const symbol in tokenData) {
                 const token = tokenData[symbol];
                 const option = document.createElement('option');
                 option.value = symbol;
                 option.textContent = `${token.name} (${symbol})`;
                 option.dataset.logo = token.logoUrl || ''; // Store logo URL if available

                 fromTokenSelect.appendChild(option.cloneNode(true));
                 toTokenSelect.appendChild(option.cloneNode(true));

                 // Set default different selections if possible
                 if (firstOption) {
                     fromTokenSelect.value = symbol;
                     firstOption = false;
                 } else if (toTokenSelect.value === fromTokenSelect.value) {
                     toTokenSelect.value = symbol; // Try to select a different second token
                 }
             }

             // Ensure default selections are different if possible
             if (fromTokenSelect.value === toTokenSelect.value && toTokenSelect.options.length > 1) {
                 toTokenSelect.selectedIndex = 1;
             }
             updateSwapRate(); // Update rate after populating
         }

         function populateWithdrawTokenSelector() {
            withdrawTokenSelect.innerHTML = ''; // Clear
             let hasOptions = false;
            for (const asset in userBalance) {
                 if (userBalance[asset] > 0 && tokenData[asset]) { // Only list owned assets with known token data
                     const token = tokenData[asset];
                     const option = document.createElement('option');
                     option.value = asset;
                     option.textContent = `${token.name} (${asset})`;
                     option.dataset.logo = token.logoUrl || '';
                     withdrawTokenSelect.appendChild(option);
                     hasOptions = true;
                 }
            }
             if (!hasOptions) {
                 const option = document.createElement('option');
                 option.textContent = 'No assets to withdraw';
                 option.disabled = true;
                 withdrawTokenSelect.appendChild(option);
             }
             updateWithdrawForm(); // Update available balance display
         }

         function updateSwapUI() {
             // Enable/disable swap button based on inputs and balance
             const fromAsset = fromTokenSelect.value;
             const fromAmount = parseFloat(fromAmountInput.value || 0);
             const balance = parseFloat(userBalance[fromAsset] || 0);
             const toAsset = toTokenSelect.value;

             if (fromAsset && toAsset && fromAmount > 0 && fromAsset !== toAsset && balance >= fromAmount) {
                 swapButton.disabled = false;
             } else {
                 swapButton.disabled = true;
             }
             updateSwapRate(); // Also update the calculated rate and toAmount
         }

         function updateSwapRate() {
            const fromAsset = fromTokenSelect.value;
            const toAsset = toTokenSelect.value;
            const fromAmount = parseFloat(fromAmountInput.value || 0);

            if (!fromAsset || !toAsset || !tokenData[fromAsset] || !tokenData[toAsset] || fromAsset === toAsset) {
                swapRateEl.textContent = 'Select different tokens to see rate';
                toAmountInput.value = '';
                return;
            }

            const fromPrice = parseFloat(tokenData[fromAsset].priceUSD || 0);
            const toPrice = parseFloat(tokenData[toAsset].priceUSD || 0);

             if (fromPrice <= 0 || toPrice <= 0) {
                 swapRateEl.textContent = 'Pricing info unavailable';
                 toAmountInput.value = '';
                 return;
             }

            const rate = fromPrice / toPrice;
            const calculatedToAmount = fromAmount * rate;

            swapRateEl.textContent = `1 ${fromAsset} ≈ ${formatTokenAmount(rate, 4)} ${toAsset}`;
            toAmountInput.value = isNaN(calculatedToAmount) ? '' : formatTokenAmount(calculatedToAmount, 6); // Update 'To' amount field
        }

        function updateWithdrawForm() {
             const selectedAsset = withdrawTokenSelect.value;
             const availableBalance = parseFloat(userBalance[selectedAsset] || 0);
             withdrawAvailableBalanceEl.textContent = `${formatTokenAmount(availableBalance)} ${selectedAsset}`;

             const withdrawAmount = parseFloat(withdrawAmountInput.value || 0);
             const recipient = recipientInfoInput.value.trim();

             if (selectedAsset && withdrawAmount > 0 && recipient && availableBalance >= withdrawAmount) {
                 withdrawButton.disabled = false;
             } else {
                 withdrawButton.disabled = true;
             }
         }


        // --- ACTION HANDLERS ---
        async function handleSwap() {
             const fromAsset = fromTokenSelect.value;
             const toAsset = toTokenSelect.value;
             const fromAmount = parseFloat(fromAmountInput.value);
             const toAmount = parseFloat(toAmountInput.value); // Use the calculated value

             if (!currentUser || !fromAsset || !toAsset || fromAsset === toAsset || isNaN(fromAmount) || fromAmount <= 0 || isNaN(toAmount)) {
                 showMessage(swapMessage, "Invalid swap parameters.", "error");
                 return;
             }

             const fromBalance = parseFloat(userBalance[fromAsset] || 0);
             if (fromBalance < fromAmount) {
                 showMessage(swapMessage, `Insufficient ${fromAsset} balance.`, "error");
                 return;
             }

             showLoading(true);
             swapButton.disabled = true;

             try {
                 // 1. Decrease 'from' asset balance
                 await updateBalance(currentUser.id, fromAsset, -fromAmount);
                 // 2. Increase 'to' asset balance
                 await updateBalance(currentUser.id, toAsset, toAmount);
                 // 3. Record the transaction
                 await recordTransaction(currentUser.id, {
                     type: "swap",
                     fromAsset: fromAsset,
                     fromAmount: fromAmount,
                     toAsset: toAsset,
                     toAmount: toAmount,
                 });

                 showMessage(swapMessage, `Successfully swapped ${formatTokenAmount(fromAmount)} ${fromAsset} for ${formatTokenAmount(toAmount)} ${toAsset}!`, "success");
                 // Clear inputs after successful swap
                 fromAmountInput.value = '';
                 toAmountInput.value = '';

             } catch (error) {
                 console.error("Swap Transaction Error:", error);
                 // IMPORTANT: Need logic here to potentially revert the first balance update if the second one fails.
                 // Firebase transactions help, but atomicity across multiple paths needs careful handling (e.g., cloud function).
                 // For this simulation, we'll show an error, but the state might be inconsistent if only one update succeeded.
                  if (error && error.message.includes('Insufficient')) {
                     showMessage(swapMessage, `Swap failed: Insufficient ${fromAsset} balance.`, "error");
                 } else {
                     showMessage(swapMessage, "Swap failed. Please try again.", "error");
                 }
             } finally {
                 showLoading(false);
                 updateSwapUI(); // Re-enable button if conditions met, update balances
             }
         }

        async function handleWithdraw() {
             const asset = withdrawTokenSelect.value;
             const amount = parseFloat(withdrawAmountInput.value);
             const recipient = recipientInfoInput.value.trim();

             if (!currentUser || !asset || isNaN(amount) || amount <= 0 || !recipient) {
                 showMessage(withdrawMessage, "Invalid withdrawal details.", "error");
                 return;
             }

             const balance = parseFloat(userBalance[asset] || 0);
             if (balance < amount) {
                 showMessage(withdrawMessage, `Insufficient ${asset} balance.`, "error");
                 return;
             }

             showLoading(true);
             withdrawButton.disabled = true;

             try {
                 // 1. Decrease balance
                 await updateBalance(currentUser.id, asset, -amount);
                 // 2. Record transaction
                 await recordTransaction(currentUser.id, {
                     type: "withdraw",
                     asset: asset,
                     amount: amount,
                     to: recipient, // Store recipient info (e.g., chat id for simulation)
                     status: "pending" // Or "completed" for simulation
                 });

                 showMessage(withdrawMessage, `Withdrawal of ${formatTokenAmount(amount)} ${asset} initiated (simulation).`, "success");
                 // Clear inputs
                 withdrawAmountInput.value = '';
                 recipientInfoInput.value = '';

             } catch (error) {
                 console.error("Withdrawal Transaction Error:", error);
                  if (error && error.message.includes('Insufficient')) {
                     showMessage(withdrawMessage, `Withdrawal failed: Insufficient ${asset} balance.`, "error");
                 } else {
                    showMessage(withdrawMessage, "Withdrawal failed. Please try again.", "error");
                 }
                 // Again, error handling for partial success is needed in real apps.
             } finally {
                 showLoading(false);
                 updateWithdrawForm(); // Re-enable/disable button, update balance display
             }
         }

         // --- EVENT LISTENERS ---
         function setupEventListeners() {
             // Navigation
             navItems.forEach(item => {
                 item.addEventListener('click', () => {
                     showPage(item.dataset.page);
                 });
             });

             // Swap Page
             fromTokenSelect.addEventListener('change', updateSwapUI);
             toTokenSelect.addEventListener('change', updateSwapUI);
             fromAmountInput.addEventListener('input', updateSwapUI);
             swapButton.addEventListener('click', handleSwap);
             swapDirectionBtn.addEventListener('click', () => {
                 const fromVal = fromTokenSelect.value;
                 fromTokenSelect.value = toTokenSelect.value;
                 toTokenSelect.value = fromVal;
                 updateSwapUI(); // Update rates and amounts after swap
             });


             // Deposit Page - Copy Chat ID
             depositChatIdEl.addEventListener('click', () => {
                 navigator.clipboard.writeText(currentUser.id)
                     .then(() => {
                         copyFeedbackDepositEl.textContent = 'Copied!';
                         setTimeout(() => { copyFeedbackDepositEl.textContent = ''; }, 2000);
                     })
                     .catch(err => {
                         copyFeedbackDepositEl.textContent = 'Failed to copy';
                         console.error('Failed to copy Chat ID: ', err);
                         setTimeout(() => { copyFeedbackDepositEl.textContent = ''; }, 2000);
                     });
             });

             // Withdraw Page
             withdrawTokenSelect.addEventListener('change', updateWithdrawForm);
             withdrawAmountInput.addEventListener('input', updateWithdrawForm);
             recipientInfoInput.addEventListener('input', updateWithdrawForm);
             withdrawButton.addEventListener('click', handleWithdraw);

              // --- Optional Deposit Simulation ---
             /*
              const simulateDepositBtn = document.getElementById('simulateDepositBtn');
              const depositAmountSimInput = document.getElementById('depositAmountSim');
              if (simulateDepositBtn && depositAmountSimInput) {
                  simulateDepositBtn.addEventListener('click', async () => {
                      const amount = parseFloat(depositAmountSimInput.value);
                      if (!currentUser || isNaN(amount) || amount <= 0) {
                          showMessage(depositMessage, 'Please enter a valid amount to simulate deposit.', 'error');
                          return;
                      }
                      showLoading(true);
                      try {
                          await updateBalance(currentUser.id, 'USDT', amount);
                          await recordTransaction(currentUser.id, {
                              type: "deposit",
                              asset: "USDT",
                              amount: amount,
                              status: "completed"
                          });
                          showMessage(depositMessage, `Successfully simulated deposit of ${formatTokenAmount(amount)} USDT.`, 'success');
                          depositAmountSimInput.value = '';
                      } catch (error) {
                          console.error("Simulated Deposit Error:", error);
                          showMessage(depositMessage, 'Failed to simulate deposit.', 'error');
                      } finally {
                          showLoading(false);
                      }
                  });
              }
              */
         }

        // --- INITIALIZATION ---
        functioninitializeApp() {
            tg.ready(); // Let Telegram know the web app is ready
            tg.expand(); // Expand the web app to full height

             showLoading(true);
             console.log("Telegram WebApp Initialized");
             // console.log("Init Data Unsafe:", tg.initDataUnsafe); // Debugging

             if (tg.initDataUnsafe && tg.initDataUnsafe.user) {
                 currentUser = tg.initDataUnsafe.user;
                 // Security Note: In production, VERIFY tg.initData on your backend!
                 console.log("User Data:", currentUser);

                 if (initializeFirebase()) {
                    // Fetch data only after Firebase is confirmed to be initialized
                    Promise.all([
                        getTokenData(), // Fetch token definitions first
                        getUserData(currentUser.id) // Fetch/create user data (depends on getTokenData for balance calc)
                    ]).then(() => {
                        console.log("Initial data loaded.");
                        updateHomePageUI(); // Initial UI update after all data is fetched
                        setupEventListeners(); // Setup listeners after initial data load
                    }).catch(error => {
                        console.error("Error during initial data fetch:", error);
                        showGlobalMessage("Error loading initial application data.", "error");
                    }).finally(() => {
                         showLoading(false); // Hide loading indicator after all fetches
                    });
                 }
             } else {
                 console.error("Could not get user data from Telegram.");
                 showGlobalMessage("Error: Could not identify user. Please run this app through Telegram.", "error");
                 showLoading(false);
                 // Optionally disable all functionality
                 document.querySelectorAll('button, input, select').forEach(el => el.disabled = true);
                 userNameEl.textContent = "Error";
             }

             // Set background color based on Telegram theme (optional)
             document.body.style.backgroundColor = tg.themeParams.bg_color || '#121212';
             document.body.style.color = tg.themeParams.text_color || '#ffffff';
             // You might need to update CSS variables dynamically if you want full theme support
             // document.documentElement.style.setProperty('--bg-color', tg.themeParams.bg_color); ... etc.

        }

        // Start the app when the DOM is ready
        document.addEventListener('DOMContentLoaded', initializeApp);

    </script>

</body>
</html>
